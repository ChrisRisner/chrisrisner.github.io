---
layout: post
title: "Building Cross-Platform Line of Business Apps with Xamarin and Mobile Services"
date: Wed Apr 16 2014 14:00:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Azure, Xamarin, Windows Phone, Visual Studio, Mobile Services, iOS, Android, .Net]
excerpt: "This post describes the demos given as part of the Building Cross-Platform Line of Business Apps with Xamarin and Mobile Services session at Build 2014."
logoUrl: null
keywords: xamarin,azure,mobile,cross,cross-platform,mobile services,active directory,service bus,relay,push,notifications,notification hubs
filepath: 2014-04-16-Building-Cross-Platform-Line-of-Business-Apps-with-Xamarin-and-Mobile-Services.html
disqus_identifier: Building-Cross-Platform-Line-of-Business-Apps-with-Xamarin-and-Mobile-Services
---
<p><img style="float: right; margin: 0px 0px 5px 5px; display: inline" src="https://crcomcstorage.blob.core.windows.net/images/XamarinLogo.png" width="217" align="right" height="188" /></p>  <p><strong>TLDR: </strong>I did a session on x-plat apps focusing on using Xamarin and Azure Mobile Services.&#160; I had some demo issues (some my fault some <em>not</em>).&#160; This post explains everything and links to the <a title="Build 2014 Chat Demo Code" href="https://github.com/ChrisRisner/Build2014Code">code</a>.</p>  <p>This year at Build, I did a session on <a title="Building Cross-Platform and Line of Business Apps with Azure Mobile Services" href="https://channel9.msdn.com/Events/Build/2014/3-622">Building Cross-Platform and Line of Business Apps with Azure Mobile Services</a>.&#160; Joining me for the session was <a title="Donna on Twitter" href="https://twitter.com/lindydonna">Donna Malayeri</a> who is a Program Manager on Mobile Services.&#160; The goals for the session were two: show off the new offline capabilities in the .NET SDK for Mobile Services and demonstrate how developers can use Xamarin to build cross-plat apps that take advantage of Line of Business or enterprise capabilities.&#160; Donna focused primarily on the offline area of the session and did a great job of demonstrating the differences between the normal data access in the SDK and the offline access, how and when you should use offline, and how to handle conflicts.&#160; My demos on the other hand had a few issues.&#160; My hope is to walk through how to reproduce what I was demoing as well as to point out the issues I ran into and how to overcome them.</p>  <p><strong>Xamarin’s iOS Build Host</strong></p>  <p>One of the biggest pain points in demoing Windows Store and iOS apps at the same time is actually deploying to either an iOS device or simulator.&#160; Let me step back and explain in more detail.&#160; If you’re building a solution with a Windows Store, Windows Phone, Android, and iOS project in them (i.e. a really cross-platform app) then you (currently) HAVE to build from Visual Studio.&#160; With Xamarin installed, you can build a Windows Store / Windows Phone / Android project with no issues.&#160; However, in order to build the iOS app, you have to pair your Windows machine with an OS X computer running the <a title="Xamarin iOS Build Host" href="http://docs.xamarin.com/guides/ios/getting_started/introduction_to_xamarin_ios_for_visual_studio/">Xamarain.iOS Build Host</a>.&#160; The Build host allows you to send instructions from Visual Studio to build an app or deploy to a simulator or device.&#160; Unfortunately, as of today, this system is not without it’s quirks.&#160; You have to be running the same version of Xamarin.iOS on both computers, you can’t pair with more than one open instance of Visual Studio, the connection can get screwed up, etc.&#160; It’s a big flakey.&#160; Even now I’m suffering from an issue where I can deploy to the iOS Simualtor but not a connected device (still no idea why).&#160; This was one of the issues I ran into and unfortunately, I still don’t have a solid fix for it.&#160; The best alternative I’ve found is to put my code into Git after changing it on the Windows machine, then pull it down on the OS X machine, and then open the solution in Xamarin Studio on iOS.&#160; Xamarin Studio won’t be able to load the Windows Store or Windows Phone projects, but you can build and run the iOS project without issues.&#160; Hopefully Xamarin will continue to make the Build Host better and this problem will disappear.&#160; </p>  <p><strong>Making a Mobile Services PCL</strong></p>  <p>The first thing I demoed was taking a Windows Store project and an iOS project and creating a new Portable Class Library that contains the Mobile Services code.&#160; The take away from this is that you can truly share your code (or at least most of it) across your different client platforms.&#160; The Mobile Services team has made a lot of strides toward making this step really simple.&#160; Unfortunately, there is a small issue affect the <strong>BCL</strong> libraries that makes a small modification necessary.&#160; Thankfully it’s quite easy to fix things.&#160; First, from Visual Studio you should have your solution with the different client projects present.&#160; <strong>Note</strong> that if you decide to start off with the WinStore and Xamarin.iOS quickstart projects from the Mobile Services page, you’ll want to remove the nuget for Mobile Services from the WinStore project and the Mobile Services component from the Xamarin.iOS Project.</p>  <p>Next, add a new project to your solution and choose <strong>Portable Class Library</strong>.&#160; You’ll next be asked to select what platforms you want your PCL to support:     <br /><img title="PCL Support" style="float: none; margin-left: auto; display: block; margin-right: auto" alt="PCL Support" src="https://crcomcstorage.blob.core.windows.net/images/pcl-project-type.jpg" width="336" height="406" />     <br />Select whichever platforms you want to support here.&#160; One thing you’ll notice is that once you select either Xamarin.Android or Xamarin.iOS, you’ll get a warning that says they are both going to be selected because you don’t need anything additional to support both versus just one.&#160; Once you’ve added the project, you can then add a reference to the PCL from your client projects (right click on Project and choose Add, Reference).&#160; </p>  <p>The next step is to drop in Mobile Services.&#160; For this, right click on your Solution and go to <strong>Manage NuGet Packages for Solution</strong>.&#160; Search for <strong>Azure Mobile</strong> and choose to install the Mobile Services package:</p>  <p><img title="Azure mobile nuget" style="float: none; margin-left: auto; display: block; margin-right: auto" alt="Azure mobile nuget" src="https://crcomcstorage.blob.core.windows.net/images/azure-mobile-nuget.jpg" width="483" height="103" /></p>  <p>Next, you’ll be asked which projects you want to install to.&#160; Make sure you select your PCL and your client projects.&#160; You’ll then get a license acceptance window.&#160; Finally, the package and it’s dependencies will be installed.&#160; If you build right now you’ll see a few errors for <strong>An assembly with the same identity has already been imported</strong>.&#160; This occurs for <strong>System.IO</strong>, <strong>System.Runtime</strong>, and <strong>System.Threading.Tasks </strong>but only for the iOS and Android projects.&#160; Go ahead and remove the references to those libraries from your iOS and Android project and you should be able to compile.&#160; We still need to make two changes for our application to work though.&#160; The first change requires replacing the contents of the <strong>app.config</strong> that is generated for the iOS and Android project.&#160; The contents of those files should look like this:</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=appconfig.xml"></script></p>  <p>Now that that’s done, we can make the last change.&#160; In your iOS project’s <strong>AppDelegate </strong>class, put <strong>CurrentPlatform.Init()</strong> at the bottom of the <strong>FinishedLaunching </strong>method.&#160; For your Android project, place the same code somewhere in your main Activity.&#160; Now you should be able to compile and run your app on all of the platforms and then proceed to start making use of Mobile Services from the PCL.</p>  <p><strong>Adding Azure Active Directory Auth and handling project specific code</strong></p>  <p>One of the interesting things about using PCLs and Xamarin is that even though we can put a LOT of our code into the PCL so it’s shared, we still can’t put everything.&#160; One clear example of that is the UI and code that is called directly by the UI (i.e. event handlers).&#160; Using Mobile Services built in authentication is another example.&#160; To understand why, it’s helpful to step back and understand how that auth works.</p>  <p>Mobile Services allows you to do two forms of authentication:&#160; client side and server side.&#160; On the client side, you use a SDK provided by the auth provider (i.e. Facebook, Google, Microsoft, Twitter) to allow the user to login.&#160; Your app then gets whatever key and secret is returned by the provider.&#160; You can then pass this information to your Mobile Service and the service will give you back a user ID and auth token you can use to make secure calls to your service.&#160; The server flow presents a web view to the user which loads a URL on your Mobile Service which in turn redirects the user to a login page on the provider’s site.&#160; This flow uses something called OAUTH.&#160; No matter which one you choose, you’re left NEEDING to do client specific code.&#160; In the server flow, each platform has a specific way of presenting the web view and each Mobile Services client library has a method specifically for that platform.&#160; For Windows Store and Windows Phone apps, you don’t need to pass any context to the UI when you authenticate (the Mobile Services Client knows what it needs to).&#160; However, for iOS you have to pass over the currently displayed UIViewController.&#160; For Android, you have to pass over the current Activity (context).&#160; For this reason, to authenticate we need to have some client specific code.&#160; </p>  <p>So the question becomes, how do we do this in a way that makes sense and is extensible.&#160; What I like to do is add an <strong>abstract </strong>class to my PCL named <strong>PlatformSpecific</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=PlatformSpecific.cs"></script></p>  <p>There are a few methods here to handle logging information (logging is another platform specific implementation) but the important method is the <strong>Authenticate</strong> method.&#160; This method returns a <strong>MobileServiceUser</strong> (i.e. our authenticated user) and takes in two <strong>objects</strong>.&#160; We take in two generic <strong>objects</strong> because we are going to pass in objects from our platform specific projects which the other projects don’t know about.&#160; For example, from iOS we’ll pass in a UIViewController for the <strong>uiObject</strong>, but the WinStore, Android, and WinPhone projects wouldn’t know what that is.&#160; Once you’ve done that then you can add a class to each of your client projects that has the code for that specific platform.&#160; Here’s the iOS code:</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=iOSSpecific.cs"></script></p>  <p>Note that we’re casting the <strong>uiObject </strong>to a <strong>UIViewController</strong> and passing it in to the <strong>LoginAsync </strong>method that is defined in the iOS <strong>Ext</strong> library for Mobile Services (automatically added when we added the NuGet).&#160; The Android, Windows Store, and Windows Phone versions will look similar but appropriate for their platforms.&#160; </p>  <p>What’s great about doing this in our platform specific classes is now we can still trigger the authentication from our shared PCL code.&#160; Our PCL has a reference to a <strong>PlatformSpecific </strong>object which is set by each of our client projects.&#160; So in our PCL, we can use this code:</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=authenticate.cs"></script></p>  <p></p>  <p>First we check to make sure the <strong>CurrentUser</strong> isn’t already set (i.e. they aren’t already logged in) and then we call the platform specific implementation of Authenticate which in turn calls back to our client project!</p>  <p><strong>Handling Push Notifications with Notification Hubs</strong></p>  <p>Push notifications are an interesting area of any client app development.&#160; From the client side, it varies from super easy to mildly complicated.&#160; The server side is absolutely terrible if you have to develop it all yourself.&#160; Thankfully, <a title="Azure Notification Hubs" href="http://azure.microsoft.com/en-us/documentation/services/notification-hubs/">Azure Notification Hubs</a> makes the server side (and some oft he client side) super easy.&#160; There isn’t a library we can use (that I know of) that prevents us from having to do some more client side code.&#160; In this case it makes sense because push is a very platform specific thing.&#160; For Windows Store and Windows Phone, we just have to register for a <strong>Channel URI</strong> from the app’s <strong>onLaunched</strong> method.&#160; For iOS, we have to register in the <strong>AppDelegate</strong> and then we get our token in the <strong>RegisteredForRemoteNotification</strong>s method.&#160; In both of these cases once we get a channel URI or push token, we can send them into our PCL code.&#160; Android is a bit more complicated but the concepts end up being the same.&#160; Rather than explain in more detail and show lots of code in an already long article, I’ll point you at these resources for Xamarin push for <a title="Xamarin.iOS Push" href="http://docs.xamarin.com/guides/cross-platform/application_fundamentals/notifications/ios/remote_notifications_in_ios/">iOS</a> and <a title="Xamarin Android Push Notifications" href="http://docs.xamarin.com/guides/cross-platform/application_fundamentals/notifications/android/remote_notifications_in_android/">Android</a> and these for <a title="Windows Store Push Notifications" href="http://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-get-started-push/">Windows Store</a> and <a title="Windows Phone Push" href="http://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-phone-get-started-push/">Windows Phone</a>.</p>  <p>Now once you have your channel URI / token / registration ID, you’re ready to register with Notification Hubs.&#160; Notification Hubs itself doesn’t currently have a PCL based library for handling registration.&#160; This ends up being ok because in this situation, it’s better for us to send our Push Identifier up to our Mobile Service and have it register with Notification Hubs on behalf of the device.&#160; I’ll get into this in a minute when I explain the tags.&#160; In the PCL, we’ll add this code which we can call from any project (or from earlier after we’ve authenticated):</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=RegisterWithNotificationHubs.cs"></script></p>  <p>Notice that we’re sending up the device’s platform, the user’s name, as well as the Push Identifier (again this is the Channel URI, token, or Registration ID).&#160; Now on the Mobile Service side, we add a custom API named <strong>RegisterForPush</strong> and set it to do the following:</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=RegisterForPush.js"></script></p>  <p>First we pull out all the parameters sent up.&#160; We also pull out the <strong>Installation ID</strong>.&#160; This is a randomly generated string that is created at first run through for any application using the Mobile Services SDK.&#160; We then get a reference to the <strong>azure </strong>module (this gives us access to talk to Notification Hubs).&#160; We then create a reference to our Hub using the hub name and full access signature (which I’ve set as App Settings on the <strong>Configure</strong> tab of my Mobile Service).&#160; Next we have methods to handle <strong>registrationComplete</strong> and <strong>logErrors</strong>.&#160; We then call <strong>listRegistrationsByTag</strong> and pass in the installation ID.&#160; This returns to us a list of any registrations that are currently tied to our installation ID.&#160; So if a device has registered before, we’ll get that registration.&#160; We then loop through the registrations and delete them.&#160; This effectively means that we’ll make sure all existing registrations are gone before we then proceed to register.&#160; </p>  <p>To register we check the platform.&#160; Each platform expects to get it’s payload in a specific format.&#160; So inside the check for each platform, we fill a template object with the format.&#160; We can then use either the <strong>gcm</strong>, <strong>apns</strong>, <strong>mpns</strong>, or <strong>wns</strong> methods to register with our hub.&#160; To the registration methods, we pass the push identifier, a list of tags, the template, and the registration complete method.&#160; Tags are an interesting and awesome thing.&#160; They allow us to tie a registration to different strings (in this case the username, the platform, “AllUsers”, and the installation ID).&#160; Registering with the username allows us to push a message to all of the devices belonging to a specific user (i.e. send this push to all of Chris’ devices).&#160; The platform means we can send a push to all users on a platform (i.e. push to everyone on Windows).&#160; “AllUsers” means we can send a push that EVERYONE will get.&#160; Lastly, the installation ID is a useful way for us to make sure each device only has one registration (which we used before to delete any existing ones).&#160; </p>  <p>Now that we’re handling registering, we can take a look at actually delivering a push notification.&#160; Notification Hubs has several ways we can talk to it including: a <a title="Notification Hubs REST API" href="http://msdn.microsoft.com/library/azure/dn223264.aspx">REST API</a>, a <a title="Notification Hubs .NET library" href="http://www.nuget.org/packages/WindowsAzure.ServiceBus/">.NET NuGet Package</a>, an <a title="Notification Hubs Java Library" href="https://github.com/fsautomata/notificationhubs-rest-java">unofficial Java library</a>, and lastly, a <a title="Notification Hubs Node Library" href="https://github.com/Azure/azure-sdk-for-node">Node.JS package</a>.&#160; This Node package is what we used previously from Mobile Services to register with Notification Hubs.&#160; Now we’ll use the same thing to trigger our push:</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=MessageInsert.js"></script></p>  <p>In this example (and from the Build session) the users were sending a message and were able to specify a recipient.&#160; Prior to implementing push, this Message insert script would just save the data.&#160; Now we save the data and then do a push.&#160; We get access to our hub using the azure module again.&#160; We then create a payload (this payload variable matches up with what we used in our template earlier).&#160; We check to make sure a recipient was specified and if not we use “AllUsers” and we then use the hubs <strong>send</strong> method to deliver the message.&#160; That’s all we have to do, Notification Hubs will take care of the rest!</p>  <p>If you were present at my session, you’ll probably remember this not working very well (push notifications weren’t being delivered).&#160; The reason in this case was human error.&#160; I missed copying the script to actually DO the push notification when a message was saved.&#160; Simple enough to fix though and everything does work just fine.</p>  <p><strong>Connecting back to on-premise</strong></p>  <p>The last piece of my Build demo involved connecting back to an on-premise service.&#160; On this topic, I would first point people at <a title="Integrating Mobile Services with Service Bus Relay" href="http://code.msdn.microsoft.com/windowsazure/How-to-integrate-a-Mobile-1ee6a5ea">Paolo Salvatori’s great walkthrough on integrating a Mobile Service with a REST Service Bus Relay Service</a>.&#160; That walkthrough is great though it uses WCF which was a bit more than I wanted to showcase in the short time I had available during this session.&#160; I find WebAPI is a good deal simpler to digest if you don’t have as much time.&#160; Unfortunately, it isn’t QUITE as easy to connect Web API to Service Bus Relay.&#160; Thankfully, <a title="Connecting WebAPI to Service Bus Relay" href="http://pfelix.wordpress.com/2012/03/15/asp-net-web-api-creating-an-host-using-azure-service-bus/">Pedro Felix does a great job of explaining how you do it here</a> (and includes all the code in a GitHub repo).&#160; </p>  <p>Now Service Bus Relay is a really awesome service.&#160; What it allows you to do is connect one service to it (say something running in my data center (which doesn’t require firewall changes!)).&#160; Once connected, if you communicate with the Service Bus Relay URL, it will pass that through to your service running on your data center without you worrying about the underlying architecture.&#160; In this sample, I actually had my client applications talk to a custom API in my Mobile Service which THEN spoke with the Service Bus Relay which took it back to the Web API running locally on my laptop.&#160; If I wanted to, I could lock my Web API down to ensure it was only accessible from Azure IPs as well.&#160; Let’s take a look at the script our Mobile Service uses for this:</p>  <p><script src="https://gist.github.com/ChrisRisner/10752731.js?file=getContacts.js"></script></p>  <p>Here we use the <strong>request</strong> module to perform our HTTP request and then return the contents we get from Service Bus Relay back to the calling application.</p>  <p>This demo also ran into a few issues.&#160; I believe it just had to do with the network connectivity changing but am not certain.&#160; I tested it right after the session and later on an airplane and had no issues (including any with latency).</p>  <p><strong>The code</strong></p>  <p>All of the <a title="Chat Demo on GitHub" href="https://github.com/ChrisRisner/Build2014Code">code for this demo is available for you to grab on GitHub</a>.&#160; There is a little bit of setup you’ll be required in order to run things but it’s all documented in the readme file.&#160; Hopefully this post and the repo provides enough information to duplicate the different system interactions and see how everything works.&#160; As always, reach out to me with questions.</p>