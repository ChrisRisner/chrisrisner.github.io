---
layout: post
title: "Authentication with iOS and Windows Azure Mobile Services"
date: Mon Apr 22 2013 13:13:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Azure, Mobile Services, Objective-C, iOS, XCode]
excerpt: "This post details how to connect an iOS application to a Windows Azure Mobile Service and allow the user to login with Facebook, Google, Microsoft, or Twitter accounts.  Additionally, we'll show how to provide the ability to create a new account to login with."
logoUrl: null
keywords: Mobile Services,Azure,authentication,facebook,google,twitter,microsoft,custom auth,social,identity,login,logout,token,userid,caching auth,ios,objective-c
filepath: 2013-04-22-Authentication-with-iOS-and-Windows-Azure-Mobile-Services.html
disqus_identifier: Authentication-with-iOS-and-Windows-Azure-Mobile-Services
---
<p><img title="Mobile Services with Android" style="float: right; margin: 0px 0px 5px 5px; display: inline" alt="Mobile Services with Android" align="right" src="http://storage.chrisrisner.com/images/WAMobileServicesblue.png" />
<strong>Update 4/22/2014: Version 1 JWTs have been deprecated.  Make sure you <a href="http://chrisrisner.com/Version-1-of-the-Mobile-Services-JWT-token-has-been-deprecated" title="Update to JWT Creation">check out this post</a> to see how the script for JWT creation needs to be changed.</strong>
<br /><br />
This article is the companion to one I just <a title="Service side of Authentication and Mobile Services" href="http://chrisrisner.com/Authentication-with-Windows-Azure-Mobile-Services">posted about handling different types of authentication with Windows Azure Mobile Services</a>.&#160; Prior to taking a look through this article and the mentioned code, I would go through the <a title="Authentication and Mobile Services" href="http://chrisrisner.com/Authentication-with-Windows-Azure-Mobile-Services">original article</a> on Mobile Services and auth.&#160; This article will cover how to connect the Mobile Service we set up there with an iOS client using the Mobile Services SDK for iOS.&#160; All of the source code for this iOS app is <a title="iOS and Mobile Services App Source Code" href="https://github.com/WindowsAzure-Samples/iOS-MobileServices-Authentication">available here in GitHub</a>.&#160; I’m going to cover a few different areas in the app in this post:&#160; giving users the choice of how to login, creating and logging in with custom accounts, logging users out and returning to the root view controller, caching user tokens so we won’t have to login each time, and dealing with expired tokens now that we’re caching them.</p>  <p><strong>Giving the user choice</strong></p>  <p>This is one of the easiest things to do from a front end perspective because all I need to do is give the user the ability to select their authentication provider:</p>  <p align="center"><img title="Login proviers" alt="Login proviers" src="http://storage.chrisrisner.com/images/ios-auth-providers.jpg" width="230" height="342" /></p>  <p>All I’ve done is put one button for each provider and then the custom auth at the bottom.&#160; Each of these buttons (except for the last) will call the same method and pass in the provider’s name:</p>  <blockquote>   <p>[self loginWithProvider:@”MyProvider”]</p> </blockquote>  <p>Depending on which button is clicked, one of the following is sent in: <strong>facebook</strong>, <strong>google</strong>, <strong>microsoftaccount</strong>, <strong>twitter</strong>.&#160; I do want to highlight here that all of these are exactly as you’d expect, except the Microsoft one.&#160; I’m not exactly sure why it’s like that.&#160; Next we have the <strong>loginWithProvider</strong> method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=loginWithProvider.m"></script></p>  <p>Here the first thing we do is record which provider the user selected in a variable inside the <strong>authService</strong> (which is a class I have wrapped all of my Mobile Service functionality in).&#160; We then create a <strong>MSLoginController </strong>using our <strong>authService</strong>’s <strong>client</strong> property.&#160; That get’s presented to the user.&#160; When that method’s callback is called, we log the error if there was one and, if not, we save the auth info (which we’ll talk about later) and then trigger the <strong>loggedInSegue</strong>.&#160; I’m going to highlight how I created that segue because it was something I didn’t know about before this sample.&#160; If you open up your storyboard (I’m using storyboards for everything here) you can <strong>control + click and drag</strong> from the <strong>View Controller</strong> icon under your view to another <strong>View Controller</strong> and create a segue which you can then give an <strong>Identifer</strong> so you can call it from the code:</p>  <p align="center"><img title="Create actionless segue" alt="Create actionless segue" src="http://storage.chrisrisner.com/images/ios-storyboard-from-vc.jpg" /></p>  <p>So even though there’s nothing in my UI triggering this segue (like there would be if I’d done the same thing from a button instead of the icon) I’m able to use this segue from my code behind.&#160; So here, once the user has logged in successfully, we’re taking them to a page that’s “inside the authentication wall”.&#160; We’ll talk about what happens in there a bit later, but first, let’s talk about what happens when you hit the <strong>Login with Email</strong> button.</p>  <p><strong>Custom auth</strong></p>  <p>When you tap the <strong>Login with Email</strong> button, you’re taken (via segue) to a login page where the user can enter their username and password:</p>  <p align="center"><img title="Custom auth login page iOS" alt="Custom auth login page iOS" src="http://storage.chrisrisner.com/images/ios-auth-custom-login.jpg" width="282" height="306" /></p>  <p>Let’s take a look at logging the user in here before we look at registering their account.&#160; When the user taps <strong>Login</strong> we call the following code:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=tappedLogin.m"></script></p>  <p>Here we’re building a <strong>NSDictionary </strong>with the username and password and then passing that to the <strong>loginAccount</strong> method of the <strong>authService</strong>.&#160; In the callback, we’re checking to see if the <strong>NSString </strong>that is returned is equal to <strong>SUCCESS</strong>, and if so, we’re dismissing this view and then calling the <strong>customAuthSegue </strong>segue.&#160; This segue is defined just like the one above but on our<strong> CustomLoginViewController</strong>.&#160; If we didn’t have a success, then we’re setting a label below the buttons to whatever message was returned.&#160; Inside my <strong>AuthService</strong>, I have the <strong>loginAccount</strong> method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=loginAccount.m"></script></p>  <p>This method creates a <strong>NSDictionary </strong>to store parameters for the query string and adds one named <strong>login</strong>.&#160; If you recall from the previous article about the server side scripts, when we do an insert on the <strong>Accounts</strong> table and <strong>login </strong>is a query string parameter, it knows we’re trying to log the user in as opposed to register a new account (since we’re using the same script for both things).&#160; We then call the <strong>insert</strong> method on the <strong>accountsTable</strong>.&#160; If there was an error we call the completion handler with the error text (which sets it to the label on the screen), and if not, we create a new <strong>MSUser</strong> using the <strong>userId</strong> that is returned and then set it’s <strong>mobileServiceAuthenticationToken</strong> using the <strong>token</strong> that was returned from the insert call.&#160; We then set the <strong>client</strong>’s <strong>currentUser</strong> to be equal to that and call the <strong>saveAuthInfo</strong> method before finally returning <strong>SUCCESS</strong>.&#160; One thing I’ll point out is that I didn’t put any validation in to check that they entered a username or password.&#160; This is definitely something you’ll want to do in your own apps to make them user-friendly.</p>  <p><strong>Registering accounts</strong></p>  <p>If the user taps <strong>Register for Account</strong>, we’ll take them to this view:</p>  <p align="center"><img title="Register account view" alt="Register account view" src="http://storage.chrisrisner.com/images/ios-auth-register-account.jpg" width="226" height="295" /></p>  <p>Here the user enters all of their information and then taps <strong>Register</strong>.&#160; This calls the <strong>tappedRegister</strong> method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=tappedRegister.m"></script></p>  <p>The first thing we do here is check to make sure they’ve entered data and that it’s valid.&#160; After that, we build our <strong>NSDictionary</strong> with the necessary information and pass that to the <strong>registerAccount</strong> method on <strong>AuthService</strong>.&#160; If this comes back with a <strong>SUCCESS </strong>message, we dismiss the view and call the <strong>customAuthSegue</strong> which will take us to the logged in view.&#160; If not, we display the error on the screen.&#160; Let’s look at <strong>registerAccount</strong> next:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=registerAccount.m"></script></p>  <p>As you can see, this is the exact same as the <strong>loginAccount</strong> method earlier, we’re just not passing the <strong>login</strong> parameter in.&#160; Now let’s take a look at how we save the account info.</p>  <p><strong>Saving account info</strong></p>  <p>To store our account info, we’re using something in iOS called the <a title="Keychain docs" href="http://developer.apple.com/library/ios/#documentation/Security/Reference/keychainservices/Reference/reference.html#//apple_ref/doc/uid/TP30000898">Keychain</a>.&#160; You can read a lot about the keychain if you want or you can skip that for now and just know that we use it to securely store data on our device.&#160; The KeychainWrapper’s provided in Apple’s docs don’t actually account for Automatic Reference Counting (ARC) so instead of using their files, we’re going to take the version from <a title="Chris Lowe&#39;s security tutorial" href="http://www.raywenderlich.com/6475/basic-security-in-ios-5-tutorial-part-1">Chris Lowe’s iOS Security tutorial here</a>.&#160; This <a title="Ray Wenderlich license" href="http://www.raywenderlich.com/faq">code is available under the MIT license</a> so we can use it (as long as we know it’s our responsibility if anything crazy happens).&#160; Once you’ve added those files to a project you can then use the methods in your code.&#160; Here we’re using it to save our data in the <strong>saveAuthInfo</strong> method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=saveAuthInfo.m"></script></p>  <p>We’re simply storing the <strong>userId</strong> and <strong>token</strong> properties.&#160; Now that we’ve seen how we can cache the user token and ID, let’s see how we can load that when the app starts.</p>  <p><strong>Loading the auth info</strong></p>  <p>When our application starts, in the first <strong>View Controller</strong>, we’re initializing the <strong>AuthService</strong> which calls this <strong>init </strong>method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=authServiceInit.m"></script></p>  <p>The important call here is the call to <strong>loadAuthInfo</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?loadAuthInfo.m"></script></p>  <p>Inside that method, we’re first fetching the <strong>userid</strong> from our Keychain.&#160; If that value isn’t null, we create a new <strong>MSUser </strong>for the <strong>client.currentUser</strong> and then set it’s <strong>mobileServiceAuthenticationToken</strong>.&#160; Now we finally see where this is called and set from our initial <strong>View Controller</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=ViewControllerViewDidLoad.m"></script></p>  <p>After the <strong>AuthService</strong> is set up, we check if it’s <strong>client.currentUser.userId</strong> property isn’t <strong>NIL</strong> and if so, we call the <strong>loggedInSegue</strong>.&#160; This segue (just like the earlier ones that aren’t connect to a UI element) takes the user into the logged in section of the app and by passes the login screen.&#160; So now we’ve seen how to cache the current user’s token and user ID and how we can load it when the application starts.&#160; Next let’s talk about how we can trigger logouts.</p>  <p><strong>Logging the client out</strong></p>  <p>To log out of this application, there is a logout button on our <strong>LoggedInViewController</strong>:</p>  <p align="center"><img title="logged in view" alt="logged in view" src="http://storage.chrisrisner.com/images/ios-auth-logged-in-vc.jpg" width="220" height="324" /></p>  <p>This logout button is connected to a segue, but not just any kind of segue, an <a title="Unwind Segues" href="http://chrisrisner.com/Unwinding-with-iOS-and-Storyboards">unwind segue</a>.&#160; Unwind segues are a way for us to trigger returning back to a certain point in the application flow.&#160; So if I want to return back to the view with all of the login options, this is perfect for it.&#160; To create an unwind segue, we first have to add a method to a <strong>View Controller</strong>.&#160; This method needs to have a return type of <strong>IBAction</strong> and a <strong>UIStoryboardSegue</strong> parameter.&#160; Here’s the method we have in the initial <strong>View Controller</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=logout.m"></script></p>  <p>The only thing we’re doing is calling the <strong>killAuthInfo</strong> method on <strong>authService</strong>.&#160; From a code perspective, none of this is saying “roll back all the view controllers until you get here”.&#160; iOS actually handles that for us.&#160; All we have to do is connect the <strong>Logout</strong> button to that segue.&#160; In order to do that, we can <strong>control + click and drag</strong> from the button down to the green <strong>Exit</strong> indicator beneath the <strong>View Controller</strong>:</p>  <p align="center"><img title="Connecting an exit segue" alt="Connecting an exit segue" src="http://storage.chrisrisner.com/images/ios-auth-exit-segue.jpg" width="133" height="371" /></p>  <p>When you release, any method that matches the <strong>IBOutlet / UIStoryboardSegue</strong> method format will show up for us to select.&#160; So when a user taps that button, iOS says “I’m going to roll back to the first View Controller that implements the matching method (so watch out if you have multiple unwind methods named the same thing) as well as calling that method.&#160; So now that we’re back to the initial <strong>View Controller</strong>, let’s look at the <strong>killAuthInfo</strong> method that is called:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=killAuthInfo.m"></script></p>  <p>The first thing this method does is delete the <strong>userid</strong> and <strong>token</strong> items from the Keychain.&#160; After that we go through the cookies and remove them.&#160; The reason we do this is that logging in through any of the built in providers (Facebook, Google, Microsoft, and Twitter) sets cookies on the <strong>UIWebView</strong> that is used to display the login pages.&#160; If these cookies were left there and we tried to log back in using the same provider, then that provider would say we were already authenticated.&#160; One caveat to this is that here we’re removing ALL of the cookies from our app.&#160; If we were using <strong>UIWebView</strong>’s for more than just that, this could cause a problem if we remove cookies we don’t want to.&#160; Lastly we call <strong>logout </strong>on the <strong>client</strong>.&#160; This currently just sets the <strong>currentUser</strong> to <strong>NIL</strong>.&#160; Now the last thing we need to look at is how to handle expired tokens.</p>  <p><strong>Handling expired tokens</strong></p>  <p>The motivation for handling this came from another post by Josh Twist which <a title="Josh&#39;s post on handling expired tokens" href="http://www.thejoyofcode.com/Handling_expired_tokens_in_your_application_Day_11_.aspx">you can check out here</a>.&#160; The idea is that if your app makes a request to your Mobile Service that SHOULD get through because the user is authenticated and you receive a 401 (unauthorized error) it means the user token you’re passing over has expired.&#160; There are a couple of ways we could handle this.&#160; In the completion handler for every method that we have that interacts with our Mobile Service, we could check for a 401 response, or we can handle things in one place: the <strong>MSFilter</strong>’s <strong>handleRequest</strong> method.&#160; Basically, when you say that your service class (<strong>AuthService</strong> here) implements the <strong>MSFilter</strong> protocol, you’re saying you’ll also be implementing the <strong>handleRequest </strong>method which will be called for each request you make to your Mobile Service.&#160; Here’s the <strong>handleRequest</strong> method in our <strong>AuthService</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=handleRequest.m"></script></p>  <p>The only thing we’re doing in this method is calling <strong>onNext</strong> and specifying a method to call when we get a response.&#160; That method is <strong>filterResponse</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=filterResponse.m"></script></p>  <p>In this method we first check to see if the response was a 401, if not we just call <strong>onResponse</strong> which continues to deliver the response to the completion handler the call to the Mobile Service had.&#160; If it was a 401, we first call <strong>killAuthInfo</strong> to remove all the authentication info.&#160; We then check to see if the <strong>shouldRetryAuth</strong> boolean has been set to true (we’ll get to where that is set soon).&#160; If it isn’t true, or the auth used was the custom auth, then we call a <strong>triggerLogout</strong> method (we’ll look at that in a second).&#160; We’re checking for custom auth because we haven’t implemented a popup to let the user log back in with custom auth.&#160; We could of course create something like that and show it, I just haven’t done it for this sample.&#160; Provided the boolean is true and we used a non-custom auth, then we proceed to call <strong>loginWithProvider</strong> on the <strong>client </strong>to pop up the login window again.&#160; When we get our response back from the login window, if they didn’t log in successfully, then we call <strong>triggerLogout</strong> (they had a chance to log back in and missed it).&#160; If they did login successfully, then we save the new auth info with <strong>saveAuthInfo</strong> and then we recreate the original request.&#160; We first take a <strong>mutableCopy</strong> of the original request.&#160; We then set that <strong>NSMutableURLRequest</strong>’s <strong>X-ZUMO-AUTH</strong> header to the new auth token.&#160; Finally we add a new query string parameter and tell our filter to process the request again.&#160; Now if you remember how we implemented the <strong>BadAuth </strong>service so it would trigger a 401, you’ll remember that if the request contains a query string parameter named <strong>bypass</strong>, then we return a normal 200 response.&#160; We fix this with the <strong>addQueryStringParamToRequest</strong> method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=addQueryStringParamToRequest.m"></script></p>  <p>Here we’re assuming there isn’t already any query string parameters but that’s a safe thing to do because we know exactly what the original request was.&#160; Plus, if we really had an expired token and fixed the issue, we wouldn’t need to worry about a bypass parameter.&#160; The <strong>triggerLogout </strong>method is called whenever we want to force our user back to the login screen from our filter:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=triggerLogout.m"></script></p>  <p>Here we make sure the auth info was killed, then we get the top <strong>View Controller</strong> and tell it to perform the <strong>logoutSegue</strong> segue.&#160; This segue is defined like the others to be an untrigger segue, this one on the root <strong>View Controller</strong>.&#160; Finally, let’s look at the method we use to trigger that call to the <strong>BadAuth </strong>method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5399676.js?file=testForced401.m"></script></p>  <p>Here we’re taking in the retry parameter which will dictate whether or not we try the re-login or if we just force the user out.</p>  <p><strong>Conclusion</strong></p>  <p>Today we looked at how to implement an iOS client with access to each of the built in authentication providers as well as how to handle custom authentication.&#160; We reviewed how to register a user for new accounts as well as how to login with them.&#160; We also saw how to cache the user’s auth token so they don’t have to login each time the app runs and how to reload that auth information.&#160; With all of this, you could pretty much just drop in whatever functionality you want only logged in users to have access to.&#160; There are some further things you might want to handle such as sending an email to the user after they register for an account to make sure the email address they used is valid (which you can do with <a title="Sending email with SendGrid and Mobile Services" href="http://www.windowsazure.com/en-us/develop/mobile/tutorials/send-email-with-sendgrid/">SendGrid</a>) as well as offering <strong>Forgotten Password</strong> functionality.&#160; These are things that are definitely part of a full application and should be considered.</p>