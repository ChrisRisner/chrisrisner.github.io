---
layout: post
title: "Mobile Geolocation Apps with Windows Azure Websites Part 4: Displaying Points of Interest in Android"
date: Fri Sep 21 2012 08:45:00
commentsOn: true
status: publish
type: post
published: true
categories: [Android, Azure, Mobile, Java]
excerpt: "This article walks through creating an Android application with geolocation capabilities.  We'll demonstrate creating a new app, connecting it to a PHP service running in Windows Azure Websites, and displaying points of interest near the user's current location on a MapView"
logoUrl: null
keywords: Android,Eclipse,Java,Windows Azure,Azure,PHP on Azure,Mobile connectivity to Windows Azure,Android Azure,Geolocation,Geospatial,Walkthrough,Tutorial
filepath: 2012-09-21-Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-4--Displaying-Points-of-Interest-in-Android.html
disqus_identifier: Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-4--Displaying-Points-of-Interest-in-Android
---
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" title="Windows Azure and iOS Mapping" alt="Windows Azure and iOS Mapping" align="right" src="http://chrisrisner.com/upload/windowsazure-google-maps.jpg" width="266" height="114" />In the <a title="Setting up the PHP Geolocation Code" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-1--The-PHP-Code">first article</a> in this <a title="Mobile Geolocation clients with Android and iOS and Windows Azure Websites" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites">series</a>, we walked through creating a site in Windows Azure Websites and deploying a PHP web service to it.&#160; This PHP service exposed three important endpoints:&#160; getting a collection of points of interest, getting a shared access signature (for uploading files), and adding new points of interest.&#160; Today we’re going to build an Android client that is capable of displaying a map with these points of interest on it.&#160; We’ll also poll the user’s current location in the application so they will see all the points of interest around their current position.&#160; in the next few articles, we’ll continue to talk about how to add new points of interest.&#160; </p>  <p>If you haven’t already done so, you’ll need to go through <a title="Setting up the Geolocation PHP Code" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-1--The-PHP-Code">part 1 in this series</a> to set up a Windows Azure Website running the PHP service. To do this you will need to have a Windows Azure account. If you don’t already have a Windows Azure account, you can <a title="Free Windows Azure Trial" href="http://aka.ms/MobileGeolocationWithWindowsAzureWebsites">sign up for a free trial here</a>. Once you’ve deployed that site, you can come back and proceed with this walkthrough.</p>  <p>If you would like to jump ahead and just pull down the source code, you can access it in <a title="Geolocation Android Client GitHub Repository" href="https://github.com/WindowsAzure-Samples/Geolocation-Android-Client">this GitHub repository</a>. Note that you’ll still need to follow the instructions in the readme and configure your app. </p>  <p>We’ll be using Eclipse for this tutorial though if you use a different IDE to work with Android, you should be able to follow along without too much trouble.</p>  <p><strong>Creating the Android App</strong></p>  <p>Let’s start by creating our new application in Eclipse.&#160; Go to <strong>File -&gt; New -&gt; Android Application Project</strong>.&#160; We’ll name our new application GeoAndroid:</p>  <p align="center"><img title="New Android Geo App" alt="New Android Geo App" src="http://chrisrisner.com/upload/geodemo-new-android-app.jpg" /></p>  <p>You can leave the options for the <strong>Launcher Icon</strong> as the default or customize them if you want.&#160; In the <strong>Create Activity</strong> page, you can leave it as a Blank Activity (the default).&#160; Finally, you can use the defaults for the <strong>New Blank Activity</strong> as well.&#160; When you click finish, your app should be generated.&#160; If you run your app as is now, you should see something like this:</p>  <p align="center"><img title="new android blank activity" alt=" new android blank activity" src="http://chrisrisner.com/upload/geodemo-android-blank-activity.jpg" width="279" height="405" /></p>  <p>Now that we have our app, let’s work on the UI.</p>  <p><strong>The User Interface</strong></p>  <p>Open up the <strong>res/layout/activity_main.xml</strong> file.&#160; Currently there is only a <strong>TextView</strong> in the layout.&#160; Let’s get rid of that and replace it with two <strong>LinearLayout</strong>s each with two <strong>TextView</strong>s inside of them.&#160; The first two <strong>TextView</strong>s will show a latitude header and will show the actual latitude value.&#160; The second two <strong>TextView</strong>s will show a longitude header and the actual longitude value.&#160; You’ll also need to put a <strong>MapView</strong> beneath those <strong>LinearLayout</strong>s.&#160; When you’re done, the XML for your layout will look like this:</p>  <p><script src="https://gist.github.com/3725162.js?file=MainActivity.xml"></script></p>  <p>&#160;</p>  <p>One important thing to point is that in the <strong>MapView</strong> xml, we see “ENTER YOUR API KEY” for the API key.&#160; This won’t work.&#160; Before it will, you’ll need to get a Google Maps API key.&#160; You can <a title="Signing up for Google Maps API Key" href="https://developers.google.com/android/maps-api-signup">get a Maps API Key by signing up here</a>.&#160; Once you have that key, make sure you enter it in your XML.&#160; If you run your app now, it will error out with the following:</p>  <blockquote>   <p>E/AndroidRuntime(1410): Caused by: java.lang.ClassNotFoundException: com.google.android.maps.MapView</p> </blockquote>  <p>The reason for this is that your application doesn’t know that it needs to use the maps library. To tell the compiler that, you need to open the <strong>AndroidManifest.xml </strong>file.&#160; Add the following XML element <strong>INSIDE</strong> the application node:</p>  <blockquote>   <p>&lt;uses-library android:name=&quot;com.google.android.maps&quot; /&gt;</p> </blockquote>  <p>Now you can run your app again, but it will fail again, though with a different error:</p>  <blockquote>   <p>E/AndroidRuntime(1559): Caused by: java.lang.IllegalArgumentException: MapViews can only be created inside instances of MapActivity.</p> </blockquote>  <p>This is saying that your activity needs to be of type <strong>MapActivity</strong> to use a <strong>MapView</strong>.&#160; Open the <strong>src/com.msdpe.geoandroid/MainActivity.java</strong> file and change the class your activity extends from <strong>Activity</strong> to <strong>MapActivity </strong>(you’ll also need to add an import statement).&#160; Now if you run, your app will work, but the map won’t actually show up, just the map grid.&#160; In order for it to show the actual map, you need to add the <strong>android.permission.Internet</strong> to your manifest file.&#160; Go back to your manifest and put this between the <strong>uses-sdk</strong> node and <strong>application</strong>:</p>  <blockquote>   <p>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</p> </blockquote>  <p>Now when you run your app, you should see the map show up:</p>  <p align="center"><img title="Android Geodemo with Map Working" alt="Android Geodemo with Map Working" src="http://chrisrisner.com/upload/geodemo-android-map-showing.jpg" width="205" height="301" /></p>  <p>Before we continue on to the code, you should also add the <strong>android.permission.ACCESS_FINE_INTERNET</strong>.&#160; </p>  <blockquote>   <p>&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;</p> </blockquote>  <p><strong>Plumbing Code</strong></p>  <p>Before we work on the code to show our location and points of interest, we need to add some plumbing code.&#160; First, add a new class named <strong>Constants</strong> and leave the default subclass of <strong>java.lang.object</strong>.&#160; In this class we’re going to put a few constants we’ll use for URLs:</p>  <p><script src="https://gist.github.com/3725162.js?file=Constants.h"></script></p>  <p>&#160;</p>  <p>Make sure you replace the “yoursubdomain” with the URL of the site you created in the first article in the series.&#160; We’re going to add one more class named <strong>GeoItemizedOverlay</strong> and leave it with the same subclass.&#160; After it’s created, we’re going to change it to extend <strong>ItemizedOverlay&lt;OverlayItem&gt;</strong>.&#160; This class will be used to handle the items we display on the map:</p>  <p><script src="https://gist.github.com/3725162.js?file=GeoItemizedOverlay.java"></script></p>  <p>&#160;</p>  <p>Here we’re handling creating the overlay, adding items, and tapping those items.&#160; The only really interesting thing to point out is the <strong>onTap(int index) </strong>method.&#160; When the user taps an item on the overlay, we create a dialog with a title and description and two buttons.&#160; The first button when tapped, will launch the web browser with whatever URL has been set into the description.&#160; Later when we display our points of interest, we’ll use the URL tied to each one for that description.&#160; This gives us the ability to show whatever image is tied to a point of interest.&#160; The second button just closes the dialog.</p>  <p><strong>Pulling points of interest and showing them</strong></p>  <p>Now that we’re showing the map and have done our plumbing, let’s show the users current location and pull the near by points of interest.&#160; Open up <strong>MainActivity.java</strong>.&#160; The first thing we’re going to do is add some private variables:</p>  <p><script src="https://gist.github.com/3725162.js?file=MainActivity private vars"></script></p>  <p>Here we have an object for referencing the MapView and TextViews, an object to track our itemized overlay, a list of overlay objects (used to display each point), and a drawable we’ll use to store the image we want to draw at each point. Now let’s look at the <strong>onCreate </strong>method:</p>  <p><script src="https://gist.github.com/3725162.js?file=main_activity onCreate 1"></script></p>  <p>First we are getting references to our UI objects.&#160; We turn on the zoom controls on the map using <strong>setBuiltInZoomControls</strong> so the user can manually zoom in and out.&#160; We initialize the drawable to an image in our resources folder (I’m just using a little Android guy which <a title="Android Geo Marker" href="http://chrisrisner.com/upload/androidmarker.png">you can download here</a>).&#160; We fetch the collection of the MapView’s overlays and then add a new <strong>GeoItemizedOverlay</strong>.&#160;&#160;&#160; That overlay is used to display the points of interest.&#160; We’re also adding a <strong>MyLocationOverlay</strong> which we use to display only the user’s current location.&#160; For that overlay, we also call <strong>enableMyLocation</strong> so it knows that it should draw the user’s location on it.&#160; Lastly, we get a reference to the <strong>LocationManager</strong> which we’ll use a bit later.&#160; </p>  <p><script src="https://gist.github.com/3725162.js?file=main_activity onCreate 2"></script></p>  <p>Continuing in the <strong>onCreate </strong>method, we create a <strong>LocationListener</strong> which just calls the <strong>onLocationChanged</strong> method whenever it receives an updated location.&#160; That listener then calls the <strong>makeUseOfNewLocation</strong> method in our activity.&#160; </p>  <p><script src="https://gist.github.com/3725162.js?file=main_activity onCreate 3"></script></p>  <p>Finally, we ask the <strong>LocationManager</strong> to send updates from both the <strong>NETWORK_PROVIDER</strong> and <strong>GPS_PROVIDER</strong> to our <strong>LocationListener</strong>.&#160; If either of those don’t work, we let the user know via toast.&#160; We already added the permission required to get the user’s location to the Manifest file above, but if we hadn’t this code would not work.&#160; Next let’s look at the <strong>makeUseOfNewLocation </strong>method:</p>  <p><script src="https://gist.github.com/3725162.js?file=main_activity two"></script></p>  <p>This method first sets the two TextView’s to show the latitude and longitude.&#160; It then creates a <strong>GeoPoint</strong> using the coordinates and centers the map on it (using the <strong>animateTo </strong>method on the map’s controller).&#160; We then call <strong>loadPointsFromServer</strong> to fetch the latest points of interest given our new location and call <strong>invalidate</strong> on the map which will cause it to redraw.&#160; Let’s finish things up and look at <strong>loadPointsFromServer</strong>:</p>  <p><script src="https://gist.github.com/3725162.js?file=main_activity loadPointsFromServer"></script></p>  <p>The first thing I’m going to point out is that the network communication here is done on the MAIN THREAD!&#160; This is bad.&#160; So bad in fact that in later versions of ADT and Android, it won’t run.&#160; They really don’t want you doing network traffic on the main thread.&#160; For simplification purposes, I’m doing the code on the main thread but you should look at using either an <a title="IntentServices in Android" href="http://chrisrisner.com/31-Days-of-Android--Day-28%E2%80%93Intents-Part-3--Service-Intents">IntentService</a> or an <a title="using an AsyncTask in Android" href="http://chrisrisner.com/Windows-Azure-Websites-and-Mobile-Clients-Part-8--The-Android-Client-Finished">Async Task</a> to accomplish pulling the points of interest from the server, and then call <strong>invalidate </strong>on the map in the callback.&#160; The first thing we’re doing in the method is building our URL using the constant we added earlier and then tacking on parameters for the latitude, longitude, and the radius in meters that we want points from.&#160; We then hit the server using <strong>HttpUrlConnection </strong>and read the results back into a <strong>StringBuilder</strong>.&#160; This is turned into a <strong>JSONArray</strong> which we then loop through to grab the latitude, longitude, description, and url for each point of interest.&#160; We generate a <strong>GeoPoint</strong> from the position and create a new <strong>OverlayItem</strong> which is then added to the itemized overlay.&#160; That’s all there is to adding these points to our map.&#160; </p>  <p><strong>Running the Application</strong></p>  <p>Now if you run your application (on the emulator), you will just see the normal map initially.&#160; The reason for this is that the Android emulator can’t grab our position like the way a device can.&#160; Luckily, there are a couple ways to send the GPS coordinates to the emulator.&#160; The first way is to return to Eclipse and go to the <strong>Window </strong>menu and choose <strong>Open Perspective </strong>and <strong>DDMS </strong>(you may have to go to <strong>Other</strong> and find <strong>DDMS</strong> if it isn’t listed).&#160; With that don you’ll be taken to the DDMS tool.&#160; There is a lot that you can do with DDMS but we’re going to focus on setting the GPS coordinates of our device.&#160; </p>  <p align="center"><img src="http://chrisrisner.com/upload/geodemo-ddms-coordinates.jpg" width="277" height="420" /></p>  <p>In the top left of the DDMS tool, you’ll be able to select the emulator (or device) image that you want to interact with.&#160; You don’t need to choose the specific process of your running application though, you can just select the emulator name.&#160; After that, scroll down in the <strong>Emulator Control</strong> panel until you get to <strong>Location Controls</strong>.&#160; Here you can set a latitude and longitude and then send it to your emulator.&#160; After doing so, the map will animate over to the spot we’ve entered and will attempt to refresh the points of interest:</p>  <p align="center"><img src="http://chrisrisner.com/upload/geodemo-android-showing-poi.jpg" width="531" height="376" /></p>  <p>Now when I run and set my location to Seattle, the emulator shows the blue dot where I’m at and then pulls the near by points, which are shown with the little Android figure.&#160; If I tap on one of those points, an <strong>AlertDialog</strong> pops up giving us the ability to view the file attached to the point (the code for this was in the <strong>GeoItemizedOverlay</strong> class).&#160; In the next article we’ll discuss how to add these points of interest.</p>  <p><strong>Conclusion</strong></p>  <p>Today we walked through creating a simple Android application that will connect to a PHP service running in Windows Azure Websites and poll for geographical points of interest.&#160; We then display those points of interest as points on a map with more information provided when tapped.&#160; As I mentioned at the top, you can access the <a title="Geolocation Android App in GitHub" href="https://github.com/WindowsAzure-Samples/Geolocation-Android-Client">full version of this app on GitHub</a>.&#160; Remember that you’ll need to configure the subdomains in the <strong>Constants</strong> class before trying to run it.</p>