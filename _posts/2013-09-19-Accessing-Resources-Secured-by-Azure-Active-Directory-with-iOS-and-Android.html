---
layout: post
title: "Accessing Resources Secured by Azure Active Directory with iOS and Android"
date: Thu Sep 19 2013 11:26:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Android, Azure, Java, Mobile, Objective-C, XCode, iOS]
excerpt: "This post describes the steps necessary to authenticate users of iOS and Android apps with Active Directory (hosted in Windows Azure).  We'll walk through getting an access code, requesting an access token, decoding our claims, and how to access a web service that has been secured with AD."
logoUrl: null
keywords: Azure,Active Directory,Windows Azure,iOS,Android,Azure Active Directory,ADAL,authenticate,authorize
filepath: 2013-09-19-Accessing-Resources-Secured-by-Azure-Active-Directory-with-iOS-and-Android.html
disqus_identifier: Accessing-Resources-Secured-by-Azure-Active-Directory-with-iOS-and-Android
---
<p><img style="float: right; margin: 0px 0px 5px 6px; display: inline" align="right" src="http://storage.chrisrisner.com/images/logo-active-directory.jpg" />Identity is always a very important topic when it comes to securing resources online and accessing them from different sources.&#160; One of the very popular ways of doing this in the enterprise is with something called <a title="Active Directory" href="http://en.wikipedia.org/wiki/Active_Directory">Active Directory</a> (AD).&#160; To vastly generalize things, Active Directory is a system that keeps track of users and groups (that users can be in) and acts as an authentication and authorization service.&#160; Programs can also use these groups and users to decide what users have access to what.&#160; I know of at least a few people that would probably flay me for such a simplification of a pretty complex technology, but for today, this will do.&#160; I’m sure somewhere there are stats on how many companies are using AD to manage their user infrastructure but I would easily guess it’s “a lot” (my unofficial rumor says it’s something like 90+% of top US companies).&#160; The company I last worked for used AD quite heavily and all of the .NET applications I worked on or deployed were using AD to control permissions within the apps.&#160; One challenge that people have had though is exposing these same resources externally.&#160; Until recently, it wasn’t very easy to expose your AD structure outside your company’s datacenter.&#160; Today we’ll talk about how you can do that.&#160; </p>  <p>If you’d like to skip to the code, you can use the following links:</p>  <ul>   <li><a title="iOS and Azure Active Directory" href="https://github.com/WindowsAzure-Samples/iOS-AzureActiveDirectory">iOS Client</a></li>    <li><a title="Android and Azure Active Directory" href="https://github.com/WindowsAzure-Samples/Android-AzureActiveDirectory">Android Client</a></li>    <li><a title="Securing a REST Web Service" href="http://msdn.microsoft.com/en-us/library/windowsazure/dn169448.aspx">How to set up the web service / AD / Graph</a> </li>    <ul>     <li>If you jump right in, make sure you read below about where our steps will differ from this tutorial.</li>      <ul>       <li>I really recommend reading the whole thing before starting : )</li>     </ul>   </ul> </ul>  <p>&#160;</p>  <p><strong>Taking AD to the Cloud</strong></p>  <p>In the recent past, we launched something called <a title="Windows Azure Active Directory" href="http://www.windowsazure.com/en-us/services/active-directory/">Windows Azure Active Directory</a> (WAAD).&#160; This allows you to put your AD structure in the cloud.&#160; What’s even more powerful to current users of AD is that you can integrate your on-premises AD with Azure AD.&#160; Now you can have users authenticate internally (i.e. when they are sitting at their desk) as well as give them the ability to authenticate to your AD for any resources you’re hosting in Windows Azure.&#160;&#160;&#160; Just this week, the <a title="Active Directory Authentication Library for .NET" href="http://www.cloudidentity.com/blog/2013/09/12/active-directory-authentication-library-adal-v1-for-net-general-availability/">Active Directory Authentication Library for .NET went into General Availability (GA)</a> (ADAL) which makes it really simple to authenticate and access these locked down resources from .NET clients.&#160; This is great news for anyone building .NET client apps (whether they are Windows Store, desktop, Windows Phone, or console apps) but it does leave those of us using iOS or Android devices out in the cold.&#160; Thankfully I’ve worked out a solution to easily enable you to build apps that will authenticate against Windows Azure Active Directory so you can expose secured functionality and data to these common platforms.</p>  <p><strong>The Authentication Flow</strong></p>  <p>Regardless of if we’re building an app for iOS or Android, the flow of getting access to a resource using WAAD is going to be the same:</p>  <ul>   <li>Client shows a webview displaying the Azure Active Directory login screen.</li>    <li>User authenticates using their WAAD credentials.</li>    <li>WAAD redirects to a URL originally specified as a parameter to the webview load.&#160; This redirect includes a code.</li>    <li>Client then uses that code to request an access token (this can happen behind the scenes and does not require user action).</li>    <li>WAAD returns an Access Token to the client (amongst other information explained below).</li>    <li>Client can make requests to the secure resource (web service in this case) using that token as part of an Authorization header.</li> </ul>  <p>If you dug into the ADAL mentioned earlier, you’d see that it’s really facilitating the same flow.&#160; It transparently handles a few things we’re not going to cover today but most of those things (like caching the access token and asking for a new one when it expires) should be relatively easy for you to implement (and maybe I’ll add additional articles about how to handle them).&#160; Below, after we talk about setting up the server, we’ll look at the specific locations and URLs we need to deal with for the above flow.&#160; </p>  <p><strong>Setting up Azure</strong></p>  <p>First and foremost, if you don’t already have a Windows Azure subscription, you can sign up for an <a title="Free Windows Azure Trial" href="http://www.windowsazure.com/en-us/pricing/free-trial/?WT.mc_id=A3F51C28C">absolutely free trial here</a>.&#160; For the bulk of the work in setting up your WAAD instance and our web service, I’m going to point you to different article on <a title="Securing a Windows Store Application and REST Web Service using Windows Azure AD" href="http://msdn.microsoft.com/en-us/library/windowsazure/dn169448.aspx">Securing a Windows Store Application and REST Web Service using Windows Azure AD</a>.&#160; You’ll want to follow the flow of this tutorial until you get to the section on <strong>Creating the Windows Store Application Project</strong>.&#160; Since we’re not concerned with Windows Store here, we can skip this.&#160; </p>  <p><strong>Handling a different Redirect URI</strong></p>  <p>There is one other section we need to perform for our clients to work though and that is under <strong>Registering the Todo Client and Service with Windows Azure AD</strong>.&#160; Follow along with that and go to <a href="https://graphexplorer.cloudapp.net">https://graphexplorer.cloudapp.net</a>.&#160; There you’ll need to sign in with the admin credentials you created for your WAAD account.&#160; Lastly, when you are at the <strong>Create Application Permission</strong> screen, for the <strong>Client App URL</strong> you’ll want to enter the redirect URL that your client apps will catch.&#160; If you want to go along with how I have things set up in the source code already, just enter <strong>com.cmr.waadtest://authorize</strong> in that value.&#160; </p>  <p><strong>What to do if you’re having issues so far</strong></p>  <p>Note that if you’re not keen on doing .NET development or think something may not be working correctly on your service side, you can <a title="Source code for Web Service and Windows 8 Client" href="http://code.msdn.microsoft.com/AAL-Windows-Store-app-to-2430e331">download the completed source code for the web service (and the Windows 8 client) here</a>.&#160; You’ll just need to put in the appropriate settings in the <strong>global.asax </strong>(i.e. the <strong>domainName</strong> and <strong>audience</strong>).&#160; </p>  <p><strong>Getting away from localhost</strong></p>  <p>If you’re going to be testing the clients using the simulator / emulator, then the steps described in the set up above, where you’re using <strong>localhost</strong> and running the service locally would be fine.&#160; Of course you’ll need to figure out how to expose that localhost site to your iOS simulator running on a different computer which can all be a little confusing.&#160; The most straightforward way to handle things is to deploy the website code to Windows Azure Websites.&#160; All you have to do for this to work is change any of the URLs that are using <strong>localhost</strong> to the URL of your Windows Azure Website.&#160; This includes where you have things set up in your AD account as well as redoing the graph explorer for the correct URL and changing the URL in the web service source code in the <strong>global.asax</strong>.&#160; This can be a little confusing and may not be for the faint of heart so ask questions in the comments if you need clarification.</p>  <p><strong>Running the Clients as is</strong></p>  <p>At the time of posting, I’m leaving up the AD account and Website that would allow users to authenticate inside the apps without any changes.&#160; Provided things are still up and running (I haven’t had to take down the service / AD account) you should be able to authenticate to the apps right away using the following credentials:</p>  <ul>   <li>Username: <a href="mailto:testuser@christesttwo.onmicrosoft.com">testuser@christesttwo.onmicrosoft.com</a></li>    <li>Password: <a href="mailto:ThisIs@Test">ThisIs@Test</a></li> </ul>  <p>If those credentials aren’t working for you, assume the services aren’t up and proceed with setting up everything on the server side and then configuring your client.</p>  <p><strong>Configuring the Clients</strong></p>  <p>Rather than walk you through every line of the code for both clients, I’m going to describe the specifics of each of the authentication flow steps above.&#160; You can download the client source code from GitHub at the links below:</p>  <ul>   <li><a title="iOS and Azure Active Directory" href="https://github.com/WindowsAzure-Samples/iOS-AzureActiveDirectory">iOS Client</a></li>    <li><a title="Android and Azure Active Directory" href="https://github.com/WindowsAzure-Samples/Android-AzureActiveDirectory">Android Client</a></li> <!--EndFragment--></ul>  <p>Regardless of which client you are going to work with, <strong>before you can run</strong> you need to change some values located in either <strong>Constants.h</strong> or <strong>Constants.java</strong>.&#160; These values point to specific things we have set up in Azure or Graph Explorer.&#160; I’ll try to explain where you should get each of these values from:</p>  <ul>   <li>LOGIN_URL – this can stay as <a href="https://login.windows.net/">https://login.windows.net/</a> as that is the URL we’ll send users to login to.</li>    <li>DOMAIN – this is the domain you set up in the Azure portal and should resemble something.onmicrosoft.com</li>    <li>CLIENT_ID – this is the value you got out of the <strong>graph explorer</strong> when you created the permission.&#160; It should be the <strong>Client ID</strong> for the <strong>Client Application</strong> and will look like this <strong>fa94de18-3636-447e-8986-99db18aeac85</strong>.</li>    <li>REDIRECT_URI – this is the URI you put into the <strong>graph explorer</strong> when you created the permission and was the <strong>Client App URL</strong>.&#160; If you used the value suggested above, you can leave this as is: <strong>com.cmr.waadtest://authorize</strong>.</li>    <li>RESOURCE – this is the URL of your website and needs to match up what you entered when you created the app permission in the <strong>graph explorer</strong>.&#160; Since I pushed my site to Windows Azure websites, my URL was <strong><a href="http://win8webapp.azurewebsites.net/">http://win8webapp.azurewebsites.net/</a></strong>.&#160; Make sure you include the trailing slash as entered in for the <strong>Service App ID URI</strong>.</li>    <li>SERVICE_ENDPOINT – this is the rest of the URL for your website that would be used to access your web service.&#160; If you have used the sample site, you can leave it as <strong>api/todolist</strong>.</li> </ul>  <p>That should be it for client configuration.&#160; There are a couple source code files you’ll need to download and add to the iOS app.&#160; You can read more about these files in the GitHub Readme or open the <strong>ThirdParty/thirdparty.txt</strong> file and follow the instructions there.&#160; </p>  <p><strong>Walking through the Clients</strong></p>  <p>If you’ve implemented an OAuth authentication flow, what we’re about to walk through shouldn’t be too weird.&#160; Even if you haven’t, once you see the different steps, it should make a good deal of sense to you.&#160; With both clients, after launching the first thing we do, is wait for the user to tap the <strong>Authenticate </strong>button.&#160; Once they do, we pop open a web view which will load this URL:</p>  <blockquote>   <p>https://login.windows.net/<strong>christesttwo.onmicrosoft.com</strong>/oauth2/authorize?<strong>response_type</strong>=code&amp;<strong>resource</strong>=http://win8webapp.azurewebsites.net/&amp;<strong>client_id</strong>=fa94de18-3636-447e-8986-99db18aeac85&amp;<strong>redirect_uri</strong>=com.cmr.waadtest://authorize</p> </blockquote>  <p>This URL comprises the windows.net login URL, our domain (christesttwo.onmicrosoft.com), the response type we’re looking for (code), the resource we want to access (http://win8webapp.azurewebsites.net/), our client ID (the alphanumeric string), and our redirect URI (com.cmr.waadtest://authorize).&#160; In both iOS and Android we have the capability to intercept different URLs loading in our webview.&#160; We use this capability to catch the redirect after the user logs in (login.windows.net will redirect back to the URL we passed in as a parameter).&#160; When the user does login, the redirect will be to a URL that looks like this:</p>  <blockquote>   <p>com.cmr.waadtest://authorize/?<strong>       <br />code</strong>=AwABAAAAvPM1KaPlrEqdFSBzjqfTGE2vpMXa2tSeyt5abHfypa7ylOkmSMtkxWQWEDOkOSd5nXUCz1_GAzYPT4n5YOIlhKxyaBEprf-UxKz0SHK3E0ZRi8FtZzKuAgl6TvKCapcnlf4K0aeNlSJcgaysEMTFVbFcJ8oTBqIMjtKbPB_JhbfSMTHbSvYbxxdPK5FNOO3FmsTw-BrDz3BHrLxJioSSRlmOZ9LqxHFUh4twTMd2hhaxT69m7BozUsVYa0iGRJqVi4PeK89G17eET03tIDCGxL8BL0oMj63YskwTEgAGq-RRDHUTY_6_Pn63rn6G9DlRNd3199LnuFBXgcU2K338TMFdNjI1qVaD8gfKfKRSiF53ZWfi8DFtanSFgQvlXkbIhNhYELojnK7BwWooQaXzoCAA      <br />&amp;<strong>session_state</strong>=00a1cb02-67d2-42d5-bf03-18182d81d521</p> </blockquote>  <p>The important part here is the <strong>code</strong> that comes back.&#160; We need to pull this out.&#160; The second step in the client applications is for the user to tap the <strong>Get Token</strong> button.&#160; This step is drawn out for your benefit in understanding the different steps.&#160; In reality, you could just go straight from getting the <strong>code</strong> to getting a <strong>token</strong> (and I wouldn’t advise requiring user action to fetch that token).</p>  <p><strong>Getting a Token</strong></p>  <p>Once the user taps the <strong>Get Token </strong>button, we then do a post to this URL:</p>  <blockquote>   <p>https://login.windows.net/christesttwo.onmicrosoft.com/oauth2/token</p> </blockquote>  <p>This URL is very similar to the first one except we’re not passing any query string parameters and instead of the endpoint being <strong>authorize</strong> we’re going to <strong>token</strong>.&#160; This is the endpoint in the AD login service that will return a token to us (provided we pass the right data into the body) as opposed to asking a user to authenticate.&#160; To this URL, we need to pass the following data in URL Form-Encoded format:</p>  <ul>   <li>our Client ID</li>    <li>the <strong>code</strong> we received previously</li>    <li>the grant type (authorization code)</li>    <li>the redirect URI (this just has to match up with what we sent previously and isn’t used as a redirect)</li> </ul>  <p>We also need to specify that we expect <strong>application/json</strong> as the response type and that we’re sending over <strong>application/x-www-form-urlencoded</strong> data as the <strong>Content-Type</strong>.&#160; We post that data to the above URL and provided it’s all valid, we’ll get the following data back (in JSON format):</p>  <ul>   <li>Access Token – this is the magic key we need to get into our web service</li>    <li>Expires In – how long until the token expires</li>    <li>Expires On – when does the token expire</li>    <li>ID Token – a unique ID for the user</li>    <li>Refresh Token – this token can be used to request (behind the scenes w/o user interaction) a new Access Token when that expires</li>    <li>Resource – this should match the resource we're using in our client app</li>    <li>Scope – what is the scope of the user permission</li>    <li>Token Type – what type of token have we received (in this case Bearer)</li> </ul>  <p>At this point, we have everything we need to make requests against our secured web service.</p>  <p><strong>Making Calls</strong></p>  <p>The client application / service functions as a very simple todo list.&#160; We’re able to add items (which are stored temporarily in non-persistent storage) and can be received.&#160; So we have two different methods:&#160; get todo items and add a todo item.&#160; I won’t go into what’s going on with talking to these methods in depth because they are very simple rest calls to our resource URL plus /api/todolist.&#160; If we are fetching items, we do a GET request.&#160; If we are adding an item, we perform a POST request.&#160; When we post an item, we use JSON.&#160; When we receive the todos, they are in JSON.&#160; The only thing you need to make sure you do is set a HEADER on the request before it’s made with the name <strong>Authorization</strong> and the value:&#160; <strong>Bearer &lt;Access Token&gt; </strong>where you put your access token in (and don’t use the carrots).&#160; </p>  <p><strong>Decoding Claims</strong></p>  <p>There is one additional capability of each of the client apps and that is to decode the claims we receive as part of the Access Token.&#160; The Access Token comes over in the following format:</p>  <blockquote>   <p>eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1THdqcHdBSk9NOW4tQSJ9.eyJhdWQiOiJodHRwOi8vd2luOH     <br />dlYmFwcC5henVyZXdlYnNpdGVzLm5ldC8iLCJpc3MiOiJodHRwczovL3N0cy53aW5kb3dzLm5ldC9lZjg2YjIwYy03NzgyLTQ3M2UtOTQ1Z      <br />i01ODNiODhlYjczNWIvIiwiaWF0IjoxMzc5NjA3MjU3LCJuYmYiOjEzNzk2MDcyNTcsImV4cCI6MTM3OTYzNjA1NywidmVyIjoiMS4wIiwi      <br />dGlkIjoiZWY4NmIyMGMtNzc4Mi00NzNlLTk0NWYtNTgzYjg4ZWI3MzViIiwib2lkIjoiMzllNmZiNGMtMzZmNS00ZDY3LWJmNGYtMTk4M      <br />TZiMTlmOTljIiwidXBuIjoidXNlckBjaHJpc3Rlc3R0d28ub25taWNyb3NvZnQuY29tIiwidW5pcXVlX25hbWUiOiJ1c2VyQGNocmlzdGVzdH      <br />R3by5vbm1pY3Jvc29mdC5jb20iLCJzdWIiOiI3MnpUa09vZ0NUQnh3ZmZIQ200b005ZFFOV3E0ZWNTbzc1SlA5N3dpVmxBIiwiZmFtaWx      <br />5X25hbWUiOiJ1c2VyIiwiZ2l2ZW5fbmFtZSI6InVzZXIiLCJhcHBpZCI6ImZhOTRkZTE4LTM2MzYtNDQ3ZS04OTg2LTk5ZGIxOGFlYWM4NSI      <br />sImFwcGlkYWNyIjoiMCIsInNjcCI6InVzZXJfaW1wZXJzb25hdGlvbiIsImFjciI6IjEifQ.lsngS6CL5HQINntqJxldeScr8mYI9ULra3rqm4Y3s1Xb      <br />JpEpEMEi8PFju3jqHtOMkxxHceh1AxjZn-o3IDkqefsKtUdxQpNY_nCoUw36kTaCC9osCz3qgbcELT24ZJUOgZYRzx9fqaLT0zoX1f28ZSSLvxkLuKm86h3mCAQSNbAxvsjeXL9zwEUsc      <br />1ESJDJDg90RAwPd2h5Gx5zMhrH8JRt5hNu6PzH-GNfLs2FOfeWXGppvqxx5jMf7W-9MiY4nkbPMMmY_hbbQnNLy75Jq_-zLqLZ7fR-XMfVXP8d0OEffYjCHiszpKetBxTj8HbysglBJ8pCMefEMPQaUOBbYlA</p> </blockquote>  <p>That’s a huge mess of characters.&#160; What I would highlight are the two periods present in the string.&#160; It’s possible to decode the whole string and see what is in it, but today we’re only interested in seeing the claims.&#160; The claims are the part between the second and third periods.&#160; Once we pull that out, we can decode it.&#160; It’s a little interesting decoding this because it is Base 64 URL encoded and when you decode it, you don’t want to decode to UTF8 but to ASCII instead.&#160; Once you’ve done so, the claims look like this:</p>  <blockquote>   <p>&quot;aud&quot;:&quot;http://win8webapp.azurewebsites.net/&quot;,     <br />&quot;iss&quot;:&quot;https://sts.windows.net/ef86b20c-7782-473e-945f-583b88eb735b/&quot;,      <br />&quot;iat&quot;:1379607257,      <br />&quot;nbf&quot;:1379607257,      <br />&quot;exp&quot;:1379636057,      <br />&quot;ver&quot;:&quot;1.0&quot;,      <br />&quot;tid&quot;:&quot;ef86b20c-7782-473e-945f-583b88eb735b&quot;,      <br />&quot;oid&quot;:&quot;39e6fb4c-36f5-4d67-bf4f-19816b19f99c&quot;,      <br />&quot;upn&quot;:&quot;user@christesttwo.onmicrosoft.com&quot;,      <br />&quot;unique_name&quot;:&quot;user@christesttwo.onmicrosoft.com&quot;,      <br />&quot;sub&quot;:&quot;72zTkOogCTBxwffHCm4oM9dQNWq4ecSo75JP97wiVlA&quot;,      <br />&quot;family_name&quot;:&quot;user&quot;,      <br />&quot;given_name&quot;:&quot;user&quot;,      <br />&quot;appid&quot;:&quot;fa94de18-3636-447e-8986-99db18aeac85&quot;,      <br />&quot;appidacr&quot;:&quot;0&quot;,      <br />&quot;scp&quot;:&quot;user_impersonation&quot;,      <br />&quot;acr&quot;:&quot;1&quot;</p> </blockquote>  <p>This identifies who I am as a user but also specifies other things like which app I have access to, what type of permission it is, and more.&#160; We could use this data with the Graph Explorer API to get further information but we’ll leave that for another day.&#160; </p>  <p><strong>Next Steps</strong></p>  <p>At this point we have a web application that requires Active Directory authentication and permissions in order to use.&#160; More importantly, we have iOS and Android client applications that are capable of authenticating a user with our own Windows Azure Active Directory account and then accessing resources secured by it!&#160; This opens up a ton of scenarios, especially for enterprises that want to enable Bring Your own Device but still secure their assets.&#160; A few things which I haven’t covered today (and may go into in the future, especially if I hear people ask for it) are:</p>  
<ul>   
<li>There isn't any error handling in this example.  We'd certainly want to handle any issues if there were any.</li>
<li>Caching the Access Token / access information in case of app relaunch</li>    <li>Getting a new Access Token after expiration using the Refresh Token</li>    <li>Setting up a secured web resource (I’m pointing to a different tutorial above which works but could be better)</li>    <li>Wrapping all of the above functionality into a library you could just drop into your iOS / Android project</li>    <li>Making requests to the Graph Explorer API to get more information on your claims.</li>    <li>Explaining how you can sync your on-premise AD account with your Windows Azure one</li>    <li>Providing more specific steps about pushing the web app to Windows Azure Web Sites.</li> </ul>  <p>Clearly there is a ton more we can do to simplify authenticating with AD and accessing secured resources from different device platforms and my hope is that in the future, you’ll see this become much easier and much more accessible.&#160; Let me know if you have questions, run into issues, or anything else in the comments.</p>