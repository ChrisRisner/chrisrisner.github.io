---
layout: post
title: "iOS and Mobile Services and Windows Azure Storage"
date: Mon Apr 01 2013 09:30:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Azure, Mobile Services, iOS, Objective-C]
excerpt: "This article walks iOS developers through the Objective-C code necessary to talk to Mobile Services and use it to access Table and Blob Storage."
logoUrl: null
keywords: Mobile Services,iOS,Objective-C,Azure,Server,Storage,Table,Blob,connect mobile services,Windows Azure,Windows Azure Storage,azure module
filepath: 2013-04-01-iOS-and-Mobile-Services-and-Windows-Azure-Storage.html
disqus_identifier: iOS-and-Mobile-Services-and-Windows-Azure-Storage
---
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" title="Mobile Services with Android" alt="Mobile Services with Android" align="right" src="http://storage.chrisrisner.com/images/WAMobileServicesblue.png" />
<strong>Update 8-29-2013</strong>:<br />Since the release of this article, the iOS SDK for Mobile Services has changed so that you can no longer send a zero over as the ID.  This will lead to an invalid ID error.  I've adjusted the code shown here to send over the value 1 for the ID.  Since the ID is ignored on the server side for our storage project, this shouldn't affect anything.<br /><br />This article is the companion to one I just <a title="Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/Mobile-Services-and-Windows-Azure-Storage">posted about connecting Mobile Services to Windows Azure Table and Blob Storage</a>.&#160; Prior to taking a look through this article and the mentioned code, I would go through the <a title="Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/Mobile-Services-and-Windows-Azure-Storage">original article</a> on Mobile Services and Windows Azure Storage.&#160; This article will cover how to connect the Mobile Service we set up there with an iOS client using the Mobile Services SDK for iOS.&#160; All of the source code for this iOS app is <a title="iOS and Mobile Services App Source Code" href="https://github.com/WindowsAzure-Samples/iOS-MobileServices-Storage">available here in GitHub</a>.&#160; Since this app deals with talking to Table and Blob Storage through Mobile Services, I’m only going to highlight here when we’re talking to Mobile Services from iOS and maybe a few other important pieces.&#160; If you want to see how the entire app works (such as how we display table names and blob names in a table view) take a closer look at the source code.</p>  <p><strong>Before you run the app</strong></p>  <p>The only thing you need to do before you run this app is adjust the <strong>init </strong>method of the <strong>StorageService </strong>class to use your Mobile Service’s URL and Application Key.&#160; You can grab these by logging into the Windows Azure portal, going to your Mobile Service, and clicking the <strong>MANAGE KEYS </strong>button when viewing your service’s dashboard.&#160; Those values go into the <strong>MSClient</strong>’s <strong>clientWithApplicationURLString</strong> method call.</p>  <p><strong>The Storage Service</strong></p>  <p>All of the “action” for talking to our Mobile Service is done inside of the <strong>StorageService </strong>class.&#160; For that reason, the majority of the code we’ll look at today is from that class.&#160; The first thing we’ll look at is the <strong>init </strong>method for the class:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=init.m"></script></p>  <p>As mentioned above, you’ll need to set the <strong>mobileserviceurl</strong> and <strong>applicationkey</strong> to your Mobile Service’s before running.&#160; After that we’re just setting up some local properties like the tables we’ll use to get access to each of the Mobile Service’s tables we set up in the first article.&#160; That’s all there is as far as setup goes.&#160; Now let’s look at each individual operation in the class.</p>  <p><strong>Reading tables</strong></p>  <p>Reading tables is done in the same way we would if we were going to read data normally from Mobile Services:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=refreshTablesOnSuccess.m"></script></p>  <p>Since the iOS SDK relies upon NSDictionary which isn’t typed, we don’t need to do anything special to get the data on tables out and into a local array.&#160; After we pull down that table, we can go through the array and use each item’s <strong>TableName</strong> property to fill our table view.</p>  <p><strong>Creating tables</strong></p>  <p>Creating tables is just like a normal operation where we’re just going to pass the table name over in the NSDictionary we’re going to insert:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=createTable.m"></script></p>  <p><strong>Deleting tables</strong></p>  <p>For deleting tables, we have to do things a little differently than normal Mobile Services’ deletes:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=deleteTable.m"></script></p>  <p>Here, we’re passing the table name over as parameters.&#160; This is necessary because when you call delete, everything is stripped out of the JSON <strong>item</strong> that is sent over but the <strong>id</strong>.&#160; The idea is that on the server side you just delete by ID so you don’t need to send the other information over the wire.&#160; This means we HAVE to pass the table name over through some other means, hence, parameters.</p>  <p><strong>Reading table rows</strong></p>  <p>Once we’ve tapped on a table in our table view, we can then call the <strong>TableRows</strong> read method to get all of the row data back:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=refreshTableRowsOnSuccess.m"></script></p>  <p>Here we’re constructing a custom query string to pass into the <strong>readWithQueryString</strong> method.&#160; We’re doing this because on the server side we’re looking at the <strong>request.parameters </strong>object to get the table name we’re going to read.&#160; If you look at how we’re handling displaying the data for each row in the table view, you’ll see some “somewhat” complicated code that I pulled out of the old Windows Azure Toolkit.&#160; Since just displaying the data in a table view like that is pretty unlikely to happen, I’m not too worried about how the data is exactly displayed as long as it works.</p>  <p><strong>Inserting table rows</strong></p>  <p>Inserting rows requires us to send over both the NSDictionary with all of the row properties as well as a set of parameters with the table name in them:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=insertTableRow.m"></script></p>  <p><strong>Deleting table rows</strong></p>  <p>Just like for deleting tables, we need to handle things a little differently to delete table rows:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=deleteTableRow.m"></script></p>  <p>Here our parameters have three items in them: the table name, the Partition Key, and the Row Key.</p>  <p><strong>Updating table rows</strong></p>  <p>Just like with inserting, we pass over the NSDictionary with all of the properties on it and the parameters array with the table name in it:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=updateTableRow.m"></script></p>  <p>Table Storage itself handles updating the item by the table name, Partition Key, and Row Key.&#160; Now that we’ve looked at all of the Table operations, let’s move over to Blobs.</p>  <p><strong>Reading containers</strong></p>  <p>Reading the containers is a normal read against that table:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=refreshContainersOnSuccess.m"></script></p>  <p><strong>Creating containers</strong></p>  <p>Creating retainers requires us to pass in two things, the NSDictionary item with the container name, and a NSDicationary of parameters:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=createContainer.m"></script></p>  <p>The parameters contain the flag for whether or not the container should be public or private.&#160; If the container is created as public, we’ll be able to load up the blobs without needing a Shared Access Signature (SAS, but more on that later).&#160; </p>  <p><strong>Deleting containers</strong></p>  <p>Deleting containers, just like deleting tables, requires that we send an <strong>id </strong>over.&#160; We can’t send the container name as part of the item with the id because everything but the id will get stripped off:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=deleteContainer.m"></script></p>  <p>Instead the container name is sent over as part of the parameters.</p>  <p><strong>Reading blobs</strong></p>  <p>Reading the blobs just requires us to send over the name of the container we’re looking in.&#160; Just like when we’re getting table rows, we do this with a custom query string:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=refreshBlobsOnSuccess.m"></script></p>  <p><strong>Inserting blobs and loading the data</strong></p>  <p>Creating new blobs is handled a little bit interestingly.&#160; In order to create a blob, our Mobile Service tells Blob Storage it wants to create a new blob with a specified container name and blob name.&#160; It does this by generating a Shared Access Signature which we can use as part of a URL to then post the blob data on the client.&#160; So, from the client we call the <strong>getSasUrlForNewBlob</strong> method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=getSasUrlForNewBlob.m"></script></p>  <p>This passes the container and blob name over as parameters and it comes back with the SAS URL from the server.&#160; Once we get that back, we can then post those bytes from the client which it does with a NSMutableURLRequest and NSURLConnection.&#160; Now in the case of private containers where we can’t just use the URL of the blob to access the data,(in our case we’re saving images, so we can’t just use the blob URL to set the source of the image) we need to create a SAS URL to access that data.&#160; This method pulls double duty by fetching a read and write URL from the server.&#160; In reality we might want to split this functionality between two methods for security purposes but for this demo it’s been combined.&#160; You can see how we’re using this to load the data by checking out the <strong>tappedLoadWithSAS </strong>method in <strong>BlobDetailsViewController.m</strong>.</p>  <p><strong>Deleting blobs</strong></p>  <p>Deleting blobs is similar to deleting tables or containers:</p>  <p><script src="https://gist.github.com/ChrisRisner/5267043.js?file=deleteBlob.m"></script></p>  <p>We pass over an empty <strong>id</strong> and then put the container and blob name in the parameters that get sent over.</p>  <p><strong>Finished with storage</strong></p>  <p>That’s all we need to do from the client side.&#160; Many of these method calls you’ve seen don’t really do anything differently than calls to Mobile Services when we’re using SQL Database storage normally.&#160; Thankfully we can abstract our client away enough to not worry about some of these things.&#160; In the case of methods where we need to pass additional information, like deletes where there isn’t a JSON item being sent over, we use the option parameters value to send the information over.&#160; One important point to make is that for the purposes of this demo, everything should work regardless of what information is stored in the tables (and to some degree the blobs).&#160; In reality if you were building an application that was going to make use of Blob and Table Storage from Mobile Services, you’d in theory know what data was in your tables and blobs so things wouldn’t be handled as generically as I’ve done in this client application.</p>  <p><strong>Using NSNotificationCenter</strong></p>  <p>For this application I wanted to explore a new way of reloading the data on my table views.&#160; Normally I would generate delegates and trigger a data refresh on the delegate, which would reload the table view, whenever the data changed.&#160; For this sample I used <strong>NSNotificationCenter</strong> instead.&#160; The table view classes are setting themselves as observers of whatever the reload method is (for example <strong>refreshTableRows</strong>, <strong>refreshBlobs</strong>, etc and whenever the data changed, a notification was sent to say that data had changed.&#160; This was a pretty easy way to handle sending information back that didn’t require very much work (and arguably less code than implementing the delegates that would be used instead).</p>  <p><strong>Conclusion</strong></p>  <p>Today we looked at how to implement a client that connects to a Mobile Service that uses Table and Blob Storage.&#160; Some aspects of it are no different from using normal SQL Database storage.&#160; Some of it requires a few additional steps.&#160; With the knowledge from this article and the <a title="Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/Mobile-Services-and-Windows-Azure-Storage">server side one</a>, you should now know how to comfortably combine SQL Database, Table, and Blob Storage.&#160; A good knowledge of Blob Storage and getting SAS URLs (and how to upload blobs with them) is important even if you stick to SQL Storage since it, and the JSON that is used between the client and Mobile Services, isn’t really meant for file storage.&#160; Good luck and remember that the source code for this and the server side scripts is all <a title="iOS Mobile Services and Storage Source Code" href="https://github.com/WindowsAzure-Samples/iOS-MobileServices-Storage">available here on GitHub</a>.</p>