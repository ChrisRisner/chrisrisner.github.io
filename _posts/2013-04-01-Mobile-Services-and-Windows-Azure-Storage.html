---
layout: post
title: "Mobile Services and Windows Azure Storage"
date: Mon Apr 01 2013 09:23:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Azure, Javascript, Mobile Services, SQL]
excerpt: "This article walks developers through connecting Windows Azure Mobile Services scripts to Windows Azure Table and Blob Storage. "
logoUrl: null
keywords: Mobile Services,Azure,Server,Storage,Table,Blob,connect mobile services,Windows Azure,Windows Azure Storage,azure module
filepath: 2013-04-01-Mobile-Services-and-Windows-Azure-Storage.html
disqus_identifier: Mobile-Services-and-Windows-Azure-Storage
---
<p>
<strong>Update 3-20-2015:  If you are running into a cursor error when trying to upload a blob from the Android version like the following:<br />&nbsp;&nbsp;Couldn't read row 0, col -1 from CursorWindow.  Make sure the Cursor is initialized correctly before accessing data from it<br /><br />I'd recommend replacing the code which uses a cursor to get the image bytes with the following: </strong><br /><br />
&nbsp;&nbsp;Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(mImageUri));<br />
&nbsp;&nbsp;ByteArrayOutputStream bos = new ByteArrayOutputStream();<br />
&nbsp;&nbsp;bitmap.compress(Bitmap.CompressFormat.PNG, 100, bos);<br />
&nbsp;&nbsp;byte[] bytes = bos.toByteArray();
<br /<br />  <br />That should fix it</p>

</p>
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" title="Mobile Services with Android" alt="Mobile Services with Android" align="right" src="http://storage.chrisrisner.com/images/WAMobileServicesblue.png" />Since we launched Mobile Services, one of the common questions we get is how to connect Mobile Services with <a title="Table and Blob Storage" href="http://www.windowsazure.com/en-us/home/features/data-management/">Windows Azure Table and Blob Storage</a>.&#160; Mobile Services is built off of SQL Database which is really great for many reasons.&#160; The motivations for connecting to Table and Blob storage usually have to do with scalability, cost, and file storage.&#160; Table storage is a NoSQL data storage implementation that offers really great scalability in addition to geo-replication.&#160; Additionally, table storage is a good deal cheaper than SQL database.&#160; Blob storage is specifically suited to storing files be they images, videos, or anything else.&#160; SQL Storage makes Mobile Services a bit more straightforward but does come at the costs I just mentioned.&#160; Today, I’m happy to announce a sample which will demonstrate how you can connect your Mobile Services into Table and Blob Storage.&#160; It’s not quite as easy as flipping a switch and saying “don’t use SQL, use Tables and Blobs” but this should give you a pretty thorough understanding of how to take advantage of Tables and Blobs.&#160; Additionally, after this you should understand enough to be able to use them in conjunction with the built in SQL storage if you want.&#160; This article will cover how to handle things on the server (Mobile Services) side and the next two will cover connecting to them with the iOS and Android clients.&#160; Source code, including the server scripts, is available for <a title="iOS Mobile Services Storage" href="https://github.com/WindowsAzure-Samples/iOS-MobileServices-Storage">iOS</a> and <a title="Android Mobile Services Storage" href="https://github.com/WindowsAzure-Samples/Android-MobileServices-Storage">Android</a>.</p>  <p><strong>An important note on the difference between SQL Database and Table Storage</strong></p>  <p>A very important thing to point out is that you can’t just replace SQL Database with Table storage and think you’ll get all of the same features. Specific design and functionality has to be taken into account when using either type of storage.&#160; One very specific example of this has to do with querying your data.&#160; With Table Storage, you are able to do look ups on a table against it’s Partition Key and Row Key.&#160; That’s in.&#160; With SQL Database you can index and look up by any column in any table.&#160; It is extremely outside the scope of this article to discuss the advantages and disadvantages of the different storage systems and it would be impossible to provide a “one size fits all” answer to what you should use.&#160; When in doubt, do the proper research to understand your options.&#160; </p>  <p><strong>Setting up your Mobile Service and Storage Account</strong></p>  <p>The first step we need to take is to create a new Mobile Service and Storage Account.&#160; Before you can do that, you’ll need a Windows Azure account.&#160; If you don’t have one yet, you can <a title="Free Windows Azure Trial" href="https://www.windowsazure.com/en-us/pricing/free-trial/">sign up for a free 90 day trial here</a>.&#160; Next, as opposed to walking through the steps to setup a new Mobile Service yet again, you can reference the <strong>Setting up the app</strong> portion of <a title="Setting up a new Mobile Service" href="http://chrisrisner.com/Adding-Auth-and-Logging-out-of-an-iOS-Windows-Azure-Mobile-Services-App">this article</a>.&#160; Now that that’s done, let’s set up our Storage account.&#160; Click the <strong>+ NEW</strong> button at the bottom left of the portal and choose <strong>DATA SERVICES</strong> and then <strong>STORAGE</strong>:</p>  <p align="center"><img title="New Storage Account" alt="New Storage Account" src="http://storage.chrisrisner.com/images/azure-new-storage.jpg" /></p>  <p>Next choose <strong>QUICK CREATE</strong>, name your account, and choose it’s location:</p>  <p align="center"><img title="Storage Account Name" alt="Storage Account Name" src="http://storage.chrisrisner.com/images/azure-new-storage-2.jpg" /></p>  <p>Click the <strong>CREATE STORAGE ACCOUNT</strong> button and your account will start being created.&#160; Once it is, click into your storage account.&#160; Before we can move back into our Mobile Service, we need to get our storage account key.&#160; Once in your storage account, click the <strong>MANAGE KEYS</strong> button at the bottom:</p>  <p align="center"><img title="Manage Storage Keys" alt="Manage Storage Keys" src="http://storage.chrisrisner.com/images/azure-storage-manage-keys.jpg" /></p>  <p>In the window that pops up you’ll see a primary and secondary key.&#160; You’ll need to copy the name of your storage account and the primary key for use later:</p>  <p align="center"><img title="Storage account key and name" alt="Storage account key and name" src="http://storage.chrisrisner.com/images/azure-storage-keys.jpg" /></p>  <p><strong>Accessing Tables</strong></p>  <p>Now that we’ve set up our Mobile Service, let’s take a look at accessing Tables.&#160; Go into your Mobile Service in the portal and go to the <strong>DATA </strong>tab (it’s the link near the top under your Mobile Service name).&#160; If you started with a new service, you won’t see any tables so go ahead and click the <strong>+ CREATE</strong> button at the bottom.&#160; We’ll name this table <strong>Tables</strong> and leave the permissions to the default with the exception of <strong>READ PERMISSION</strong>.&#160; Set that to <strong>Everyone</strong>.&#160; We’re only going to do that so that we can also check our tables from the browser later on.&#160; </p>  <p align="center"><img title="New tables table" alt="New tables table" src="http://storage.chrisrisner.com/images/wams-new-table-tables.jpg" width="278" height="298" /></p>  <p>After that, click the checkmark to create your table.&#160; Once your table is generated, click on it’s name to be taken <em>into</em> the table.&#160; You’ll start by seeing that your table has no records.&#160; That’s fine and in fact, since this view is tied to what’s in the SQL Database and we’re going to use Table Storage, we’ll never see our data here.&#160; Click on the <strong>SCRIPT</strong> tab at the top.&#160; We’ll first handle the <strong>Insert </strong>script by replacing the default with this:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266066.js?file=tables.insert.js"></script></p>  <p>Make sure you replace the <strong>accountname</strong> and <strong>accountkey</strong> with the values you grabbed above for your storage account.&#160; You’ll need to do that in all of the scripts going forward.&#160; The first thing the script does is get access to the <strong>azure </strong>module.&#160; This is a <a title="Node.js Azure Module" href="https://github.com/WindowsAzure/azure-sdk-for-node">Node.js module</a> that gives us access to a lot of different things including Table and Blob storage.&#160; After we set our account name, key, and host variables, we call <strong>createTableService</strong> with them.&#160; This gives us a service we can use to access Table Storage.&#160; Next we call the service’s <strong>createTable</strong> method and pass in the <strong>tableName</strong> property that was sent into the method as JSON (into the <strong>item</strong> object).&#160; If the table was created we respond with a 200 and the <strong>item </strong>object.&#160; If not, we respond with a 500.&#160; As we continue on, you’ll see that most of the scripts look very similar.&#160; We get the account name, key, and host and use them to generate a service using the <strong>azure</strong> module.&#160; Then we do whatever we want with that service.&#160; Save that script and then use the drop down at the top to switch to the <strong>Delete</strong> script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266066.js?file=tables.delete.js"></script></p>  <p>The delete script is nearly identical to the create script.&#160; Instead of calling <strong>createTable</strong> we’re calling the <strong>deleteTable</strong> method.&#160; Also, since the <strong>delete</strong> script doesn’t take in a JSON <strong>item</strong> like the other scripts, we need to get the <strong>tableName</strong> from the <strong>request.parameters</strong> object.&#160; Lastly, we’re not returning any data on success, just the 200.&#160; Save that and then switch to the <strong>Read </strong>script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266066.js?file=tables.read.js"></script></p>  <p>The <strong>read</strong> script uses the <strong>queryTables</strong> method and returns either the error in case of an error or the actual <strong>tables</strong> data on success.&#160; That’s all we have to implement in order to insert, delete, and read tables.&#160; Next we’ll look at accessing the data inside of those tables!</p>  <p><strong>Accessing Table Rows</strong></p>  <p>Return back to the <strong>DATA</strong> tab (you can click the big arrow pointing left if you’re still on the <strong>read</strong> scripts for the <strong>tables</strong> table).&#160; Go ahead and create another table with the same permissions and name it <strong>TableRows</strong>.&#160; Click on your table after it’s created and go to the <strong>SCRIPTS</strong> tab.&#160; We’ll start with the <strong>Insert</strong> script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266066.js?file=tablerows.insert.js"></script></p>  <p>Everything is the same (again) up until we get to the <strong>insertEntity</strong> method.&#160; This method takes in the name of the table, which we’re getting from <strong>request.parameters</strong>, and the data for the table which we’ve passed over in the JSON <strong>item</strong>.&#160; Save that and move on to the <strong>Update </strong>script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266066.js?file=tablerows.update.js"></script></p>  <p>This script is completely the same except we’re calling <strong>updateEntity</strong> instead of insert.&#160; Let’s go on to <strong>Delete</strong> where things will be slightly more interesting:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266066.js?file=tablerows.delete.js"></script></p>  <p>Here, we need to send over the table name as well as the Partition Key and Row Key.&#160; All of these values are retrieved from <strong>request.parameters</strong> because, again, we can’t pass this data though on a JSON <strong>item</strong> as the delete method only takes in the <strong>id</strong> of the item to delete.&#160; Let’s wrap things up with the <strong>Read</strong> script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266066.js?file=tablerows.read.js"></script></p>  <p>Here we’re actually creating a <strong>azure.TableQuery</strong> to query Table Storage.&#160; We’re doing a very simple query here and just saying “select all the rows from the table with this name”.&#160; However, if you wanted to do more advanced querying (such as pulling all the items from a table with a certain Partition Key) this is where you would do it.&#160; Once we’ve created that <strong>TableQuery</strong> we pass that into the <strong>queryEntities</strong> method.&#160; On success we’ll return the rows of data that are returned from our query.</p>  <p>That’s all there is to the server side of accessing Table Storage.&#160; We’ll next look at dealing with Blob Storage.</p>  <p><strong>Accessing Containers</strong></p>  <p>As the first part of dealing with Blob Storage, we need to see how to look at the Containers.&#160; Containers “contain” blobs so before we can load up blobs we need to deal with what they’re in.&#160; Return to the <strong>DATA</strong> tab for your Mobile Service and create a new table with the same permissions as before and name it <strong>BlobContainers</strong>.&#160; After your table is created, click into it and go to the <strong>SCRIPT </strong>tab.&#160; We’ll start with the <strong>Insert</strong> script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266227.js?file=containers.insert.js"></script></p>  <p>Things for setting up are just a little different here than in the table scripts.&#160; First, the host is set to the accountname + <strong>.blob.core.windows.net</strong>.&#160; If the host name was left to <strong>tables.core.windows.net</strong> we wouldn’t be able to access Blob Storage.&#160; Next, we’re calling <strong>azure.createBlobService </strong>in order to get a <strong>blobService</strong> for accessing Blob Storage.&#160; That’s going to be the same for the rest of the scripts that deal with blobs.&#160; Next, we’re checking the <strong>isPublic</strong> flag in <strong>request.parameters</strong>.&#160; A container can be public or private (it’s a little more complex but that will do for this article).&#160; If it’s public, I don’t need any special permissions to access the blobs inside of it.&#160; If it’s private, it requires a bit more work but we’ll talk about that when we get down to blobs below.&#160; Either way, we’re calling the <strong>createContainerIfNotExists</strong> method and passing in the container name from the JSON item.&#160; Since the default is private, if the <strong>isPublic </strong>flag is set to true, we pass in some <strong>options</strong> that specify that the <strong>publicAccessLevel</strong> is for blobs.&#160; Once created we return to the calling app.&#160; Let’s move on to the <strong>Delete</strong> script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266227.js?file=containers.delete.js"></script></p>  <p>Deleting is very similar to the table deletion, we just call <strong>deleteContainer</strong> and pass the container name from <strong>request.parameters</strong>.&#160; Let’s wrap up containers with the <strong>Read </strong>script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266227.js?file=containers.read.js"></script></p>  <p>Here we just call the <strong>listContainers </strong>method and return the results to the calling app.&#160; Containers are now covered.&#160; We’re ready to talk about Blobs.</p>  <p><strong>Accessing Blobs</strong></p>  <p>The last step before we move to our client is how to load blobs.&#160; Go back to the <strong>DATA</strong> tab in your Mobile Service and create a new table with the same permissions named <strong>BlobBlobs</strong>.&#160; Once it’s created go in and let’s tackle the <strong>Insert</strong> script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266227.js?file=blobs.insert.js"></script></p>  <p>This script is by far the most complex one we’ll look at today.&#160; Before we talk about the code, let’s talk about how we handle inserting a blob.&#160; To insert a blob, we need to have a URL we can write to.&#160; In order for Blob Storage to be secure, we can’t just write to <a href="http://myaccount.blob.core.windows.net/mycontainer/myNewBlobName">http://myaccount.blob.core.windows.net/mycontainer/myNewBlobName</a>.&#160; Blob Storage needs to know that there is a blob there and approve us writing to it.&#160; To facilitate that, we generate a Shared Access Signature (SAS) which gives us write (and read) access to a specific blob’s URL.&#160; We can then return that SAS URL to the client who can read or write to the blob.&#160; We’re going to use the <strong>Insert</strong> method to both generate new blobs and get access to existing blobs.&#160; We could split this out and have one method for reading and one for writing, but for simplicity it’s all in one here.</p>  <p>So in the script after we call <strong>createBlobService</strong> we generate a <strong>sharedAccessPolicy</strong>.&#160; Here we’re saying we want to be able to read and write and that the SAS URL should expire in 5 minutes.&#160; If we only wanted read access, we could just change the permissions.&#160; After that we get the <strong>sasUrl</strong> object with the <strong>generateSharedAccessSignature </strong>method.&#160; That method takes in the access policy as well as the blob and container names.&#160; After that, we need to <em>build</em> our SAS URL from the properties in the <strong>sasUrl</strong> object.&#160; To do this, we use the <strong>stringify</strong> method of the <strong>querystring</strong> module to build our query string parameters.&#160; Finally we return that to the calling app.&#160; Let’s move on to the <strong>Delete</strong> script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266227.js?file=blobs.delete.js"></script></p>  <p>Back to simplicity with this as we just call <strong>deleteBlob</strong> and pass in the container and blob name.&#160; Now let’s look at the <strong>Read </strong>script:</p>  <p><script src="https://gist.github.com/ChrisRisner/5266227.js?file=blobs.read.js"></script></p>  <p>Here we call the <strong>listBlobs </strong>method and pass in the container name.&#160; This will return the details for all of the blobs in our container.&#160; That’s all for the server side scripts for accessing Table and Blob storage.</p>  <p><strong>A word about how things are set up</strong></p>  <p>These scripts and this sample were built to be a demonstration of how you might access Windows Azure Storage from Mobile Services.&#160; To that end, some of the things I’ve done could certainly be done in other ways that might fit better with what you’re trying to accomplish.&#160; For example, I used four “dummy” tables for Tables, TableRows, Containers, and Blobs.&#160; It might make more sense for you to use one table in Mobile Services to match up to each table in Table Storage (at least for ease of knowing where things are at).&#160; Alternatively, you could store some data in SQL Database and some in Table Storage.&#160; As I pointed out above, instead of using one script to get read AND write access to a blob, I could split these into two separate functions / table methods.&#160; Additionally, we could have used fields on the JSON <strong>item</strong> to specify some things (like the Table name on the TableRow update script) and then just deleted the TableName from the <strong>item</strong> before passing it over to storage if we wanted.&#160; There isn’t necessarily one way to do any of these things.&#160; </p>  <p>Finally, for more information about the <strong>azure </strong>module such as how to do more advanced queries against Table Storage, the different method overrides, as well as how to access other things like Service Bus or Queues, check out the <a title="azure module in GitHub" href="https://github.com/WindowsAzure/azure-sdk-for-node">module details in GitHub</a>.</p>  <p><strong>The Client</strong></p>  <p>Now that we’ve covered everything on the server side, we’re ready to tackle the clients.&#160; I’ve split things up so there is one article that will cover everything for Android and one for iOS.&#160; It’s important to remember though that we’re using the same Mobile Service for BOTH clients.&#160; There is no need to create a different Mobile Service for each client.&#160; You can find the specific articles for each client here:</p>  <ul>   <li><a title="Android and Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/Android-and-Mobile-Services-and-Windows-Azure-Storage">the Android Client</a></li>    <li><a title="iOS and Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/iOS-and-Mobile-Services-and-Windows-Azure-Storage">the iOS Client</a></li> </ul>  <p><strong>Conclusion</strong></p>  <p>Today we looked at how you can easily make use of Table and Blob Storage from your Mobile Services.&#160; You should be capable of understanding how to take advantage of all the different kinds of storage from Mobile Services now.&#160; Remember that there are advantages and disadvantages to all of the storage providers.&#160; Additionally, there are many different ways of doing the same things.&#160; This sample is meant to give you the basics that you can work with to craft your own solution for your apps.&#160; </p>