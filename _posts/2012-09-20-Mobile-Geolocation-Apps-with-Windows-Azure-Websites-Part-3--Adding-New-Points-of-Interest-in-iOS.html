---
layout: post
title: "Mobile Geolocation Apps with Windows Azure Websites Part 3: Adding New Points of Interest in iOS"
date: Thu Sep 20 2012 09:53:00
commentsOn: true
status: publish
type: post
published: true
categories: [Azure, Mobile, XCode, iOS, Objective-C]
excerpt: "This article continues a series on connecting iOS applications with geolocation capabilities to a PHP service running in Windows Azure Websites.  Here we pick up from the last article by adding the ability to add new points of interest which will show up in our MapView.  We will also make use of Windows Azure Storage to store images which are connected to those points of interest."
logoUrl: null
keywords: Xcode,Objective C,iOS,iPhone,Windows Azure,Azure,PHP on Azure,Mobile connectivity to Windows Azure,Geolocation,Geospatial
filepath: 2012-09-20-Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-3--Adding-New-Points-of-Interest-in-iOS.html
disqus_identifier: Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-3--Adding-New-Points-of-Interest-in-iOS
---
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" title="Windows Azure and iOS Mapping" alt="Windows Azure and iOS Mapping" align="right" src="http://chrisrisner.com/upload/windowsazure-apple-maps.jpg" width="266" height="114" />In the <a title="Displaying points of interest in our iOS Geolocation App" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-2--Displaying-Points-of-Interest-in-iOS">previous article</a> in this <a title="Geolocation with Mobile Clients and Windows Azure Websites" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites">series</a>, we walked through creating an iOS app, adding a mapview to it and displaying points of interest on it.&#160; When the user’s location changes and when the app first loads, we communicate with the PHP service we set up in the <a title="Setting up the PHP service for mobile geolocation" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-1--The-PHP-Code">first article</a>, to get all of the points of interest within a number of meters from a certain latitude and longitude.&#160; Today we’re going to look at adding new points of interest.&#160; This actually involves an interesting dance between the client application and the cloud.&#160; We’ll discuss that first.</p>  <p>If you haven’t already done so, you’ll need to go through <a title="Setting up the PHP Service for Mobile Geolocation" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-1--The-PHP-Code">part 1 in this series</a> to set up a Windows Azure Website running the PHP service. To do this you will need to have a Windows Azure account. If you don’t already have a Windows Azure account, you can <a title="Free Windows Azure Trial" href="http://aka.ms/MobileGeolocationWithWindowsAzureWebsites">sign up for a free trial here</a>. Once you’ve deployed that site, you can come back and proceed with this walkthrough.</p>  <p>If you would like to jump ahead and just pull down the source code, you can access it in <a title="Geolocation iOS Client GitHub Repository" href="https://github.com/WindowsAzure-Samples/Geolocation-iOS-Client">this GitHub repository</a>. Note that you’ll still need to follow the instructions in the readme and configure your app. One final note: this walkthrough was done with iOS 5 and the Map View element provided by it. I haven’t tried running it on an iOS6 beta yet and that does have new mapping capabilities. This steps described below may need to be altered slightly to work with iOS 6 maps.     <br /></p>  <p><strong>How do we add a point of interest</strong></p>  <p>In order to upload an image or video and tie it to a point of interest in our backend, we have to communicate with two different server components: our <a title="Windows Azure Websites" href="https://www.windowsazure.com/en-us/home/scenarios/web-sites/">Windows Azure Websites</a> PHP service and <a title="Windows Azure Blob Storage" href="https://www.windowsazure.com/en-us/home/features/data-management/">Windows Azure Blob Storage</a>.&#160; Let’s look at a diagram of the steps to do this and then discuss them:</p>  <p align="center"><img src="http://chrisrisner.com/upload/geolocation-workflow-uploading-poi.jpg" width="502" height="470" /></p>  <p>The first thing we need to do is have our client app communicate with our service running in Windows Azure Website and request a Shared Access Signature (SAS).&#160; </p>  <p>A SAS is a way around needing to have the account name and key of our storage account on the local device.&#160; If you were to put the account name and key in your client app and someone was able to pull those details out, they could then upload and access whatever they wanted in your storage account.&#160; The way around this is by using the SAS.&#160; A SAS is created to give an application the ability to upload a file to a storage account without having the name or key.&#160; Instead, a server side component has the name and key and requests the SAS from the storage account.&#160; This SAS is a URL which expires after a certain period of time (chosen by the server side component) and gives a client application the ability to upload a single file.</p>  <p>So, our client app requests the SAS from our website.&#160; The website talks to our storage account and gets the SAS.&#160; The SAS is then returned to the client application.&#160; The client app can then use the SAS URL to upload a file.&#160; After that is done, we save the point of interest (with a reference to the URL of the item uploaded to storage) inside that point of interest.&#160; Let’s get to our code and see how we can accomplish this.</p>  <p><strong>Let’s code</strong></p>  <p>Open back up Xcode and your solution we left off with the last article.&#160; As a reminder, right now the app is capable of showing the user’s current location (on a device, on the simulator you need to fake your location using the Debug menu) and the points of interest in the area of the user.&#160; As we did before, we’re going to do some plumbing to start.&#160; Open up the <strong>Constants.h </strong>file and we’re going to add some new constants for the URLs for fetching the SAS and uploading the POI in addition to a container name which we’ll also use for uploading the file to storage:</p>  <p><script src="https://gist.github.com/3723823.js?file=Constants.h"></script></p>  <p>&#160;</p>  <p>Now let’s switch over to <strong>Constants.m</strong> and define these values:</p>  <p>&#160;</p>  <p>Make sure you replace the “yoursubdomain” with the site URL you set up when you uploaded your PHP service in the first article.&#160; The container name corresponds to a test container we created in that same article.&#160; Now, add a new <strong>Objective-C class</strong> to your project named <strong>StateObject</strong>.&#160; The header file for this new object just has two properties:</p>  <p><script src="https://gist.github.com/3723823.js?file=StateObject.h"></script></p>  <p>&#160;</p>  <p>The first is for a callback block and the second is a data object to contain retrieved data.&#160; In the implementation file, we just synthesize these properties:</p>  <p><script src="https://gist.github.com/3723823.js?file=StateObject.m"></script></p>  <p>&#160;</p>  <p>This class will be used to help us with our HTTP requests in just a moment.&#160; Let’s add a new <strong>Objective-C class</strong> named <strong>ServiceCaller</strong>.&#160; This class is going to be used to perform any HTTP requests we’ll be doing in the rest of our application.&#160; It’s going to wrap to do any wrap calls to <strong>NSURLRequest</strong> (really <strong>NSMutableURLRequest</strong>).&#160; Let’s look at the header file:</p>  <p>&#160;</p>  <p>First we have a private variable which will keep track of different <strong>StateObject</strong>s for multiple requests.&#160; Next we have an <strong>init </strong>method and a method to handle starting and performing any HTTP requests.&#160; The implementation file, <strong>ServiceCaller.m</strong>, has a lot of code to go through:</p>  <p><script src="https://gist.github.com/3723823.js?file=ServiceCaller.m"></script></p>  <p>&#160;</p>  <p>First the <strong>init </strong>method which initializes the <strong>callbacks</strong> object.&#160; Next is <strong>postToUrl</strong>.&#160; This method acts as a catch all for any sort of HTTP request (yes we could pass in other optional parameters and expand this, but for today’s work, it will do).&#160; As parameters, we can specify the URL to connect to, the data to post (optional), the type of HTTP request, the content type (optional), and a callback block.&#160; We generate our <strong>NSMutableURLRequest</strong> and set any necessary parameters.&#160; Then we start a <strong>NSUrlConnection</strong>.&#160; Lastly, we save this information to a <strong>StateObject</strong> and put that in the <strong>callbacks</strong> object.&#160; The reason we’re using the <strong>StateObject</strong> and saving it like so is that it makes this class capable of handling multiple requests at the same time.&#160; The key we use in the <strong>callbacks</strong> object is the hash of the connection.&#160; So later in the file, when we receive data back, we can tie that back to the <strong>StateObject</strong> specific to the request by using the hash.&#160; </p>  <p>The next few methods are all part of the <strong>NSUrlConnectionDelegate</strong> protocol.&#160; First in <strong>didReceiveReponse</strong> we just check the response code for an error and log it.&#160; In <strong>didReceiveData</strong>, we pull out the <strong>StateObject</strong> using the connection’s hash and then append the data that was received.&#160; In <strong>didFailWithError</strong>, we log the error and then remove the <strong>StateObject</strong> from <strong>callbacks</strong> so we’re not leaving memory out there and the connection is now dead.&#160; Lastly, in <strong>connectionDidFinishLoading</strong>, we pull out the <strong>StateObject</strong> and call it’s callback block before removing the <strong>StateObject </strong>from <strong>callbacks</strong>.</p>  <p>Also, add a new <strong>Objective-C class</strong> to your project, make it subclass <strong>UIViewController</strong> and name it <strong>NewPOIViewController</strong>.&#160; We won’t edit that file now but need it for part of our UI work.</p>  <p><strong>Changing the UI</strong></p>  <p>Now that we’re done with the plumbing, let’s alter our UI so we can add a new point of interest.&#160; Open up <strong>MainStoryboard.storyboard</strong>.&#160; We left off with a single view tied to <strong>ViewController</strong>.&#160; Go ahead and select that view and go to the <strong>Editor </strong>menu and choose <strong>Embed In </strong>and <strong>Navigation Controller</strong>.&#160; You should see your storyboard change so now there is a <strong>Navigation Controller</strong> which points right to your view controller.&#160; A NavBar has also been added to your view controller.&#160; Zoom back into your view controller and drag a <strong>Bar Button Item</strong> from the UI element selector in the bottom right panel to the top right of your view controller’s navbar.&#160; This button will by default have the title “Item”.&#160; In the <strong>Attributes Inspector </strong>at the top right of the utilities pane, choose the <strong>Identifier </strong>drop down and select “<strong>Add</strong>”.&#160; You should see the button change to having a Plus in it.&#160; </p>  <p>Find the <strong>View Controller</strong> in the UI elements panel and drag one onto your storyboard.&#160; This is what we’re going to use to handle adding a point of interest.&#160; Make sure your new view controller is selected in the storyboard editor and go to the <strong>Identity Inspector</strong> in the <strong>Utilities</strong> pane.&#160; In the <strong>Class</strong> dropdown, select <strong>NewPOIViewController</strong>.&#160; Now we’ve connected the view controller in the storyboard to the controller we created in our code.&#160; Control + Click and drag from the Plus button in your original view controller’s navbar and drag over to your new view controller and release.&#160; In the dialog that pops up, choose <strong>Push</strong>.&#160; If you run your app now and tap on that button, you should see the second view controller show up.&#160; Let’s set up our UI on that view controller now.&#160; Drag the following UI elements onto your view in this order:&#160; a <strong>Round Rect Button</strong>, an <strong>Image View</strong>, another <strong>Round Rect Button</strong>, a <strong>Label</strong>, and another <strong>Round Rect Button.&#160; </strong>For the first button, make it’s title “Select image”.&#160; The second button’s title should be “Get SAS URL”.&#160; The third button’s title should be “Post POI”.&#160; The text of the label can be “SAS URL:”.&#160; When you’re done, your storyboard will look something like this:</p>  <p align="center"><img title="Final Geodemo Storyboard" alt="Final Geodemo Storyboard" src="http://chrisrisner.com/upload/geodemo-final-UI.jpg" /></p>  <p>Now select your <strong>NewPOIViewController</strong> in the storyboard and open the <strong>Assistant Editor</strong>.&#160; You’re going to want to Control + Click and drag from the buttons, image, and label to your code and generate <strong>Outlets </strong>for the ImageView, label, and the Get SAS and Post POI buttons.&#160; You also want to create <strong>Actions </strong>for all three buttons.&#160; Creating outlets and actions for the buttons will require doing the Control + Click and drag twice for these elements.&#160; When you’re done, close the <strong>Assistant Editor</strong> and open the <strong>NewPOIViewController.h </strong>file in the normal editor.&#160; On top of what you’ve already added, we’re going to make the class implement the <strong>UIImagePickerControllerDelegate </strong>protocol and add private variables for an instance of <strong>ServiceCaller</strong> and a <strong>NSString</strong> to store the SAS URL.&#160; When you’re done, you’re class will look like this:</p>  <p><script src="https://gist.github.com/3723823.js?file=NewPOIViewController.h"></script></p>  <p>&#160;</p>  <p>Now it’s time to do all the implementation.</p>  <p><strong>Implementing the New POI View Controller</strong></p>  <p>Open up <strong>NewPOIViewController.m</strong> and let’s start connecting to our service.&#160; In the <strong>viewDidLoad </strong>method we’re going to disable the Get SAS and Post POI buttons so the user can’t tap them until we want them to and we’ll also initialize the <strong>ServiceCaller</strong> object we’ll use for all our web requests:</p>  <p><script src="https://gist.github.com/3723823.js?file=NewPOIViewController.m viewDidLoad"></script></p>  <p>&#160;</p>  <p>Next we’ll handle tapping on the select image button as well as the image picker callback:</p>  <p><script src="https://gist.github.com/3723823.js?file=NewPOIViewController.m image stuff"></script></p>  <p>&#160;</p>  <p>When the user taps select image, we create a new <strong>UIImagePickerController</strong>, tell it to look at the photo library, and set it’s delegate to be the <strong>NewPOIViewController</strong>.&#160; Finally we present the picker to the user.&#160; In the callback, we are setting the ImageView’s image to whatever the user selected, dismissing the picker, and enabling the get SAS button.&#160; Next we handle when the user taps get SAS:</p>  <p><script src="https://gist.github.com/3723823.js?file=NewPOIViewController tapGetSASUrl"></script></p>  <p>&#160;</p>  <p>First we are generating a <strong>NSString</strong> with the current time in ticks.&#160; This is used as a unique name for the SAS URL file we’ll upload.&#160; We then use <strong>ServiceCaller</strong> to post to our PHP service and request a SAS URL.&#160; We pass in the code that should be executed when that request to the server is finished.&#160; In that code block, we are setting the label to whatever the URL that came back is, saving the URL locally into the <strong>sasUrl</strong> variable (after we remove the quotes), disabling the get SAS button, and enabling the post POI button.&#160; The last thing we need to do is handle posting a POI:</p>  <p><script src="https://gist.github.com/3724507.js?file=NewPOIViewController.m post POI"></script></p>  <p>&#160;</p>  <p>This looks more complicated than it is.&#160; First we get an instance of <strong>UIImage </strong>to store the image and get a <strong>NSData </strong>object with a <strong>PNG</strong> representation of the data in it.&#160; We then use <strong>ServiceCaller </strong>to post the image data to Windows Azure Blog Storage using the SAS URL we got in the previous step.&#160; The callback for that will set the label to be that call’s response first.&#160; We then get the URL string with out the SAS specific stuff and store it into <strong>poiUrl</strong> (this is the public URL of the object that we can go to in a browser to view our image).&#160; Then we build a <strong>NSDictionary</strong> with all of the data for our point of interest: the image name (defaulted to “My Image”), a UUID (dynamically generated by the method at the bottom), the latitude and longitude (fetched from <strong>NSPreferences</strong>), a type (defaulted to “1” for image), and the URL to the image in blob storage.&#160; We then use <strong>NSJSONSerialization </strong>to serialize the data into an <strong>NSData </strong>object.&#160; We use <strong>ServiceCaller</strong> again, but, we’re posting to our PHP service this time with the JSON data describing our point of interest.&#160; Finally in that post’s callback, we are popping the view controller so the user will return to the map view.&#160; </p>  <p><strong>Running the App</strong></p>  <p>When I ran the app yesterday, my <a title="Current Location in GeoDemo for iOS" href="http://chrisrisner.com/upload/geodemo-ios-running-poi.jpg">current location was in downtown Seattle, Washington</a>.&#160; I’ve altered that today to be just east of that position.&#160; Now when we run the app and tap the Add button in our NavBar, we can follow this flow:</p>  <p align="center"><img src="http://chrisrisner.com/upload/geodemo-running-final-ios.jpg" width="452" height="669" /></p>  <p>We select an image first.&#160; Then we get the SAS URL.&#160; Finally we post it (which handles both uploading the image to blob storage and the point of interest data to our service).&#160; With that done we return the user to the map and refresh the points of interest near our current location.&#160; Now we see that the original point from yesterday and our new point are showing up.</p>  <p><strong>Conclusion</strong></p>  <p>Today we finished our iOS Geolocation app.&#160; In doing so, we made more connections to our PHP service running in Windows Azure Websites in addition to using Windows Azure Blob Storage for storing images.&#160; We also saw a fairly nifty way to handle doing web requests that will handle their own callback code without continually having to implement <strong>NSUrlConnectionDelegate</strong>.&#160; I hope this has proved informative and has given you some solid understanding of how to create iOS applications with geolocation components powered by Windows Azure.&#160; As mentioned at the top, you can access the source code for the <a title="iOS Geolocation on GitHub" href="https://github.com/WindowsAzure-Samples/Geolocation-iOS-Client">full version of this app on GitHub</a>. Remember to configure the subdomains in the <strong>Constants.m</strong> file before trying to run it.</p>