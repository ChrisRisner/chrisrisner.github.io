---
layout: post
title: "New Features for Mobile Services: Custom API, Script Source Control, Shared Scripts, and NPM Support"
date: Thu Jul 25 2013 13:22:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Android, Azure, Mobile Services, Javascript, iOS]
excerpt: "This article walks you through some of the new improvements to Windows Azure Mobile Services.  This includes custom APIs, script source control, shared scripts, and Node Packages Modules (NPM) support."
logoUrl: null
keywords: Azure,Mobile Services,Mobile,Windows Azure,Scripting,BaaS,scripts,source control,custom api,api,endpoint,shared scripts,git,npm,node,package
filepath: 2013-07-25-New-Features-for-Mobile-Services--Custom-API,-Script-Source-Control,-Shared-Scripts,-and-NPM-Support.html
disqus_identifier: New-Features-for-Mobile-Services--Custom-API,-Script-Source-Control,-Shared-Scripts,-and-NPM-Support
---
<p><img style="float: right; margin: 0px 0px 5px 5px; display: inline" align="right" src="http://storage.chrisrisner.com/images/WAMobileServicesblue.png" width="156" height="230" />Last month at <a title="Build 2013 Conference" href="http://chrisrisner.com/Build-2013%E2%80%93Attack-of-the-Mobile-Services">Microsoft’s Build conference</a> in San Francisco, the General Availability of Mobile Services was announced.&#160; In addition to that, several new features were released to enhance the server side functionality of Mobile Services.&#160; Improvements to the client SDKs also came out to match.&#160; Today I’m going to walk through these new features and how to use them.&#160; Where appropriate, we’ll look at the client side code for iOS and Android.&#160; The features we’ll be talking about are:</p>  <ul>   <li>Custom APIs </li>    <li>Script Source Control </li>    <li>Shared Scripts </li>    <li>NPM Support </li> </ul>  <p>All of these have to do with server side scripting in some way.</p>  <p><strong>Custom APIs</strong></p>  <p>Prior to the release of custom APIs, the only endpoints your Mobile Service exposed were the REST APIs generated for each table you created.&#160; Furthermore, each table operation was inherently tied to the SQL database table underneath it.&#160; You didn’t (and still don’t) have to use that SQL database and could use the table operations almost like “virtual” endpoints.&#160; However, with the release of custom APIs, you no longer need to do that.&#160; Now, you can create a custom endpoint and assign different functionality to the different HTTP methods that it can receive (GET, POST, PUT, PATCH, DELETE).&#160; Creating a custom API is a cinch once you have a Mobile Service created.&#160; Go into the Windows Azure Portal and navigate into your Mobile Service.&#160; Once there, select the <strong>API</strong> tab:</p>  <p align="center"><img title="Custom API" alt="Custom API" src="http://storage.chrisrisner.com/videos/wa-portal-zumo-api.jpg" /></p>  <p>&#160;</p>  <p>Clicking on this takes you to a list of your custom APIs.&#160; If you don’t already have one, click the <strong>CREATE A CUSTOM API</strong> link which will take you to this screen:</p>  <p align="center"><img title="Create a custom API" alt="Create a custom API" src="http://storage.chrisrisner.com/videos/wa-portal-custom-api-create.jpg" width="302" height="347" /></p>  <p>Here we can name our custom API (I’ve named mine <strong>MyCustomAPI</strong>) and then choose permissions for each of the HTTP methods.&#160; These permissions work the exact same way as the table scripts permissions do.&#160; Your choices are:</p>  <ul>   <li>Everyone – Anyone with the endpoint URL can access it. </li>    <li>Anybody with the Application Key – The Application Key must come across as a header to make it through. </li>    <li>Only Authenticated Users – A valid user ID and token must come through with the request. </li>    <li>Only Administrators – Only requests with the master key as a header will make it through. </li> </ul>  <p>Once you’ve named it and selected your permissions (you can always change these later if you want), you’ll be returned to the API list with your new API now showing up (after a few seconds of it being created).&#160; Click on the name of the API to go into it.&#160; The first thing you see is the scripts window with the following script:</p>  <p><script src="https://gist.github.com/ChrisRisner/6066607.js?file=api.js"></script></p>  <p>Notice that this script is exporting functionality for the POST method by setting <strong>exports.post</strong>.&#160; We’re doing the same for GET with <strong>exports.get</strong>.&#160; In this one script we can specify functionality for all&#160; 5 of the HTTP methods.&#160; Right now both methods will return an OK response (200) with the JSON message “Hello World!”.&#160; Notice that the commented out code in the post code shows us how we can use the <strong>request.service </strong>module to access things like the <strong>tables</strong> and <strong>push</strong> modules (which are normally available without doing a special statement in our table scripts).&#160; Just like our table scripts, we can put any matter of functionality we want here.&#160; Let’s switch over to the client side now.</p>  <p><strong>Calling custom APIs from iOS</strong></p>  <p>When it comes to calling the Custom APIs from iOS, you have two different options: one that uses JSON as it’s request and response type and one that can handle any media type.&#160; The first method looks like this:</p>  <p><script src="https://gist.github.com/ChrisRisner/6066607.js?file=customJSONapi"></script></p>  <p>Notice that this methods name is <strong>invokeAPI</strong> and as a first parameter takes in the name of the custom API.&#160; The second parameter here is <strong>body</strong> which would be your JSON request object.&#160; The next parameter is the <strong>HTTPMethod</strong> which in this case is <strong>GET</strong>.&#160; Next we can optionally send in NSDictionaries containing any <strong>parameters</strong> or <strong>headers</strong> we want to apply to the request.&#160; Finally, we define a <strong>completion</strong> handler which returns a <strong>result</strong>, a <strong>response</strong>, and an <strong>error</strong>.&#160; The <strong>result</strong> parameter will be the actual JSON data you return from API method which in this case will be:</p>  <blockquote>   <p>{ message = “Hello World!” }</p> </blockquote>  <p>The <strong>response</strong> is the actual <strong>NSHTTPURLResponse </strong>and is very useful for, among other things, checking the <strong>statusCode</strong> as well as any headers returned.&#160; Lastly, the <strong>error</strong> will be filled if the API, or trying to call the API, lead to an error.&#160; </p>  <p>The second method is nearly the exact same with the differences being the data sent across and the parameter type for <strong>result</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/6066607.js?file=customDataApi.c"></script></p>  <p>Note that the second parameter is now of type <strong>NSData</strong> and so is the type of the <strong>result</strong> object.&#160; Since we are returning a <strong>NSData </strong>object, it’s up to us to decide how we want to interpret that.&#160; So if we wanted to treat the data like a string, for example, we could pull that string out like this:</p>  <p><script src="https://gist.github.com/ChrisRisner/6066607.js?file=AccessStringData.c"></script></p>  <p>If we are using data of another sort, it’s up to us to convert it correctly.</p>  <p><strong>Calling custom APIs from Android</strong></p>  <p>Now let’s take a look at calling the same API from an Android app.&#160; The Android SDK has considerably more options for invoking the API with 9 total method overrides for <strong>invokeAPI</strong>.&#160; Let’s take a look at each one.&#160; The first method just takes in the name of the API and a <strong>ApiJsonOperationCallback</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/6066607.js?file=javaInvokeApiOne.java"></script></p>  <p>This method would be used if you want to pull back arbitrary JSON that isn’t casted to a type.&#160; This method will automatically do a POST against your API.&#160; Alternatively there are some more advanced methods that deal with using raw JSON:</p>  <ol>   <li>void invokeApi(String apiName, JsonElement body, ApiJsonOperationCallback callback) </li>    <li>void invokeApi(String apiName, JsonElement body, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, ApiJsonOperationCallback callback) </li>    <li>void invokeApi(String apiName, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, ApiJsonOperationCallback callback) </li> </ol>  <p>The first method here is the same as what we did above but allows us to specify an optional JSON body that will be sent as part of the request.&#160; The next method is the same as the last but also allows us to specify which HTTP method to use (GET, POST, PUT, etc) as well as pass an optional list of parameters.&#160; Finally the last method allows us to do the same thing with no body parameter.</p>  <p>Just like how there are raw JSON and typed method calls for table operations from Android, the same exists for the custom API.&#160; The Android calls are:</p>  <ol>   <li>void invokeApi(String apiName, Class&lt;E&gt; clazz, ApiOperationCallback&lt;E&gt; callback) </li>    <li>void invokeApi(String apiName, Object body, Class&lt;E&gt; clazz, ApiOperationCallback&lt;E&gt; callback) </li>    <li>void invokeApi(String apiName, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, Class&lt;E&gt; clazz, ApiOperationCallback&lt;E&gt; callback) </li>    <li>void invokeApi(String apiName, Object body, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, Class&lt;E&gt; clazz, ApiOperationCallback&lt;E&gt; callback) </li> </ol>  <p>Here the first method does a POST to the API where the data that is returned is of type E.&#160; The second method does the same as the first but allows you to pass in an object to be serialized and sent over as the request body.&#160; The third method allows us to specify which HTTP Method to use as well as a list of parameters to be passed over.&#160; Finally, the fourth method allows us to do the same as the third but also specify an object for the request body.</p>  <p>Lastly, there is one method that can be used when you need explicit control over headers and the response:</p>  <ul>   <li>void invokeApi(String apiName, Object body, String httpMethod,List&lt;Pair&lt;String, String&gt;&gt; requestHeaders, List&lt;Pair&lt;String, String&gt;&gt; parameters, ServiceFilterResponseCallback callback) </li> </ul>  <p>This method enables you to deal with the response however you want.</p>  <p>For much more on both the client and server side for custom API, take a look at this pair of blog posts from Carlos Figueira:</p>  <ul>   <li><a title="Custom API in Azure Mobile Services" href="http://blogs.msdn.com/b/carlosfigueira/archive/2013/06/14/custom-apis-in-azure-mobile-services.aspx">Custom APIs in Azure Mobile Services</a> </li>    <li><a title="Client SDKs for Mobile Services Custom APIs" href="http://blogs.msdn.com/b/carlosfigueira/archive/2013/06/19/custom-api-in-azure-mobile-services-client-sdks.aspx">Client SDKs with Custom APIs</a> </li> </ul>  <p><strong>Script Source Control</strong></p>  <p>Now that we’ve covered the new custom API endpoints, we can switch over to Script Source Control which will lead into the other new scripting features.&#160; First, to enable Script Source Control, navigate in the portal to the Dashboard for your Mobile Service.&#160; After a moment, a link will load up on the right side under <strong>quick glance</strong>:</p>  <p align="center"><img title="set up script source" alt="set up script source" src="http://storage.chrisrisner.com/videos/wa-portal-setup-script-source.jpg" /></p>  <p>Click that link and wait while it gets thing set up.&#160; After it completes, you’ll automatically be taken to the configure page where you’ll be able to see the GIT repo URL for your scripts:</p>  <p align="center"><img title="Git Source URLs" alt="Git Source URLs" src="http://storage.chrisrisner.com/videos/wa-git-source-url.jpg" /></p>  <p>Now you can copy that URL and clone your repo locally (using “git clone &lt;repo&quot;&gt;” once you’ve installed GIT).&#160; You’ll want to use the <strong>GIT URL</strong> from that image as the <strong>DEPLOYMENT TRIGGER URL</strong> actually triggers a redeploy of your Mobile Service from your repository.&#160; After you’ve cloned that directory on your local computer, you can look at the folder structure:</p>  <ul>   <ul>     <li>Root Folder        <ul>         <li>Service            <ul>             <li>api                <ul>                 <li>mycustomapi.js </li>                  <li>mycustomapi.json </li>                  <li>readme.md </li>               </ul>             </li>              <li>scheduler                <ul>                 <li>readme.md </li>               </ul>             </li>              <li>shared                <ul>                 <li>readme.md </li>               </ul>             </li>              <li>table                <ul>                 <li>readme.md </li>                  <li>TodoItem.json </li>               </ul>             </li>           </ul>         </li>       </ul>     </li>   </ul> </ul>  <p>The <strong>Service</strong> folder is meant to contain all of the scripts your Mobile Service uses.&#160; Inside of that folder is an <strong>api </strong>folder which, as you can tell, contains the custom API we created above.&#160; If you opened up the <strong>mycustomapi.js</strong> file you’d see the exact script we had above.&#160; The accompanying <strong>mycustomapi.json </strong>file tracks the permissions for the different HTTP methods for that API.&#160; Currently that file looks like this:</p>  <blockquote>   <p>{&quot;routes&quot;:     <br />&#160;&#160;&#160; {&quot;*&quot;:      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; {&quot;get&quot;:{&quot;permission&quot;:&quot;application&quot;},      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;post&quot;:{&quot;permission&quot;:&quot;application&quot;},      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;put&quot;:{&quot;permission&quot;:&quot;application&quot;},      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;patch&quot;:{&quot;permission&quot;:&quot;application&quot;},      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &quot;delete&quot;:{&quot;permission&quot;:&quot;application&quot;}      <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; }      <br />&#160;&#160;&#160; }      <br />}</p> </blockquote>  <p>Moving on to the <strong>scheduler </strong>folder, this will contain any scheduled job scripts you’ve created.&#160; It’s good to point out that when you create a scheduled job, you’ll only see the JS file in this folder.&#160; There isn’t a JSON file to control how often the job runs or anything like that.&#160; Let’s skip over the <strong>shared</strong> folder for just a second and talk about the <strong>table </strong>folder.&#160; This contains, as you might expect, all the scripts that correspond to our tables.&#160; One thing that might seem weird is that we have a TodoItem table but there aren’t any script files for it, just the JSON file.&#160; This is because if your scripts match the default (i.e. they only call <strong>request.execute()</strong>) they won’t show up as scripts.&#160; Once you’ve changed a script to something other than the default, then it will show up in the following format:</p>  <blockquote>   <p>tablename.operation.js</p> </blockquote>  <p>So if I changed the TodoItem insert script, I would have a todoitem.insert.js file in that folder.&#160; Just like the <strong>api</strong> folder, we also have a JSON file for each table’s operations permissions.&#160; </p>  <p>Each folder also contains a readme.md file that walks you through how the files in that folder are structured.</p>  <p><strong>Shared Scripts</strong></p>  <p>Let’s head back to the <strong>shared</strong> folder.&#160; This folder allows you to create scripts whose functionality is then exposed to the other scripts in your Mobile Service.&#160; So if you have the same logic that you want to use in multiple table / API / scheduler scripts, this is where you put them.&#160; The readme.md details how to create such a script and we’ll walk through that example right now.&#160; For this scenario, we’re going to generate a calculator script that will just add two numbers together.&#160; So I’ll add a new file named <strong>calc.js</strong> to the shared folder and set it’s script to be:</p>  <blockquote>   <p>exports.add = function(a, b) { return a + b; };</p> </blockquote>  <p>The <strong>exports.add</strong> means I’m making available a method named <strong>add</strong> to whoever uses my <strong>calc.js</strong>.&#160; Now we can switch over to wherever we might want to use this script and do the following:</p>  <blockquote>   <p>var calc = require('../shared/calc.js');     <br />var result = calc.add(1,2);</p> </blockquote>  <p>So first we use <strong>require</strong> to get access to the shared script and then we can use the <strong>add </strong>method.&#160; This is just a small sample but the possibilities here are endless as far as what you can do from inside the shared scripts.</p>  <p><strong>Node Package Manager (NPM) Support</strong></p>  <p>The last feature we’ll talk about today is the new support for NPM.&#160; Node.js has a very rich ecosystem of Node modules which Node devs can use.&#160; Prior to adding support for NPM, you were stuck with the few modules we exposed to the scripts (things like azure, mssql, push, request, etc).&#160; Now, you can make use of the over 35,000 Node modules available from <a title="npmjs.org" href="https://npmjs.org/">npmjs.org</a> with ease.&#160; In order to use these modules you should first make sure NPM is installed and then open up a terminal (or powershell) and navigate to the <strong>Service</strong> folder.&#160; You can then install the module with:</p>  <blockquote>   <p>npm install modulename</p> </blockquote>  <p>Then inside the script you want to reference the module, you’ll just use the following require string:</p>  <blockquote>   <p>var mymod = require(‘modulename’);</p> </blockquote>  <p>And that’s all there is to using Node Modules with your Mobile Services</p>  <p><strong>Summary</strong></p>  <p>Today we looked at several new features of Mobile Services that are designed to give you even more power and flexibility when it comes to talking to your Mobile Service and performing server side functionality.&#160; I’ve already had people comment to me on how happy they are with shared scripting so they’re able to reuse functionality across their other scripts and in time we’ll be adding even more features to make using Mobile Services not just easy, but a real delight.  You can also take a look at many of these features being demonstrated in this article by watching <a href="http://channel9.msdn.com/Series/Windows-Azure-Mobile-Services/Custom-API-Script-Source-Control-and-Shared-Scripts-with-Mobile-Services-and-iOS" title="Video of Custom API, Script source control, and shared scripts">this video</a>.</p>