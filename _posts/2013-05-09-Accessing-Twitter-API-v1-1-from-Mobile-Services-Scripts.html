---
layout: post
title: "Accessing Twitter API v1.1 from Mobile Services Scripts"
date: Thu May 09 2013 13:19:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Azure, Mobile Services]
excerpt: "This article walks though how to connect to Twitter's v1.1 API from the Mobile Services' script layer.  It includes all code required and points out what you need to change for it to work in your own scripts."
logoUrl: null
keywords: Mobile Services,Azure,authentication,twitter,api,v1.1,1.1,v1,sign request,script,nonce,rest api
filepath: 2013-05-09-Accessing-Twitter-API-v1-1-from-Mobile-Services-Scripts.html
disqus_identifier: Accessing-Twitter-API-v1-1-from-Mobile-Services-Scripts
---
<p><img style="float: right; margin: 0px 0px 5px 5px; display: inline" align="right" src="http://storage.chrisrisner.com/images/WAMobileServicesblue.png" />Recently I had someone reach out to me as they were trying to communicate from their Windows Azure Mobile Service scripts to Twitter’s API and were running into issues.&#160; At first I didn’t understand why as everything was working for me.&#160; I then discovered that I had been using version 1.0 of the Twitter API while they were using the new 1.1 version.&#160; After a little bit of work I was able to figure out how to get through to the 1.1 API with an authenticated request from Mobile Service scripts.&#160; With the <a title="Twitter v1 API retirement" href="https://dev.twitter.com/blog/api-v1-retirement-date-extended-to-june-11">upcoming retirement of version 1.0 of the API on June 11th</a>, I felt it was important to share with people how they could also access the updated API.&#160; It’s important to note that if your application is currently using v1 of the API, it will NOT work as of June 11th.&#160; This includes if you followed along with the steps in my <a title="Authentication with Mobile Services" href="http://chrisrisner.com/Authentication-with-Windows-Azure-Mobile-Services">extensive Authentication sample</a> from a couple weeks ago (where I’m using v1 of the Twitter API to get the username).&#160; Today we’ll look at the same situation, pulling the current user’s username.&#160; However, you could use the same approach for any of the API methods.</p>  <p><strong>A word on complexity</strong></p>  <p>One of the first things you’ll notice when you look at this script is that it is pretty intense.&#160; If you were going to access Twitter from more than one script, you’d have to copy and paste a lot of the same code into your scripts resulting in some very messy scripts.&#160; We’re working on a solution to this but I can’t share any more details yet.&#160; </p>  <p><strong>Accessing v1.1 of the Twitter API</strong></p>  <p>With v1, you were able to make what was considered “unauthenticated” requests.&#160; This concept is gone (as far as I know) in v1.1.&#160; <a title="Authorizing a Twitter Request" href="https://dev.twitter.com/docs/auth/authorizing-request">Authorizing a request</a> is a slightly complicated process that involves <a title="Creating a Twitter Signature" href="https://dev.twitter.com/docs/auth/creating-signature">creating a signature</a> which is pretty complex.&#160; I’ll start by sharing the script with you and then trying to walk through individual pieces of it.&#160; Note that I’ve left all of my keys, tokens, and secrets in the script so it will be easier for you to compare them to your own when you’re setting this up.&#160; I’ve already removed the application so if you try to use this script exactly as is without setting your own information, it won’t work:</p>  <p><script src="https://gist.github.com/ChrisRisner/5549984.js?file=twitterauth.js"></script></p>  <p><strong>Setting up</strong></p>  <p>At the top you can see that we’re getting access to the <strong>crypto </strong>and <strong>querystring</strong> modules.&#160; We’ll need these later on.&#160; Next we generate a <strong>result</strong> object which is what we’ll return to the calling app later on.&#160; Commented out I have the single line of code that was needed to talk to v1 of the API to do what we’re going to accomplish here.&#160; Right at the <strong>//API 1.1</strong> comment is where we start the process of getting our signature and url ready for v1.1.&#160; The URL we’re hitting is <strong>/users/show.json</strong> (you can view the different API methods <a title="Twitter API 1.1 Methods" href="https://dev.twitter.com/docs/api/1.1">here</a>).&#160; They <strong>key</strong> is your consumer key which you can access in the Details area once you’ve created your app in Twitter:</p>  <p align="center"><img title="Twitter OAuth Settings" alt="Twitter OAuth Settings" src="http://storage.chrisrisner.com/images/twitter-oauth-settings.jpg" /></p>  <p>We then create a nonce.&#160; This is a unique token that our app needs toe generate for each request.&#160; Twitter uses this value to determine if the same request has been submitted multiple times.&#160; We then indicate the signature method we’re using (<strong>HMAC-SHA1</strong>) and the version.&#160; We specify our <strong>oauth_token</strong> which matches up with the <strong>Access Token</strong> at the bottom of the Twitter details page (you may need to click a button to generate an Access Token first):</p>  <p align="center"><img title="Twitter Access Token" alt="Twitter Access Token" src="http://storage.chrisrisner.com/images/twitter-access-token.jpg" /></p>  <p>Next we get the seconds since the epoch (rounded) and specify that we’re making a <strong>GET</strong> request.&#160; If&#160; you use a different method that requires a POST, make sure you change this or it won’t work.</p>  <p><strong>Building the signature</strong></p>  <p>Now that are variables are created, we can get into the meat of actually generating the signature.&#160; As mentioned before, the signature is fairly complex so you may want to <a title="Creating a twitter signature" href="https://dev.twitter.com/docs/auth/creating-signature" rel="Creating a twitter signature">review the documentation here</a>.&#160; The first thing we do is create an array (<strong>oauthData</strong>) which the key Twitter expects and the value we’re sending over.&#160; We then loop through that array and add each value to a <strong>sigData</strong> array.&#160; We also add the twitter ID to <strong>sigData</strong> (but not to <strong>oauthData</strong>).&#160; Next we call <strong>generateOAuthSignature</strong> and pass in the request type, the URL, and the <strong>sigData</strong> array.&#160; </p>  <p><strong>GenerateOAuthSignature</strong></p>  <p>Let’s take another look at this method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5549984.js?file=generateOAuthSignature.js"></script></p>  <p>We’re first getting the URL without any querystring parameters added to it (this is the format Twitter expects it in as part of the signature).&#160; We then generate a signing token using the <strong>Consumer Secret</strong> (from the first picture above) and the <strong>Access Token Secret</strong> (from the second picture).&#160; We then loop through the data array passed in and pull out each key (except the <strong>oauth_signature</strong> one) and put them in the <strong>keys</strong> array.&#160; After that we sort them (Twitter expects them to be in alphabetical order).&#160; We can then build our string using the request type, the url, and each key and data component, all of which has to be url encoded.&#160; If we were to print out the <strong>output+params</strong> before we called <strong>hashString</strong> on it, we’d get something like this:</p>  <blockquote>   <p>GET&amp;https%3A%2F%2Fapi.twitter.com%2F1.1%2Fusers%2Fshow.json&amp;oauth_consumer_key%3D8PDPZfA7KWbXHdDGuSCbeg%26oauth_nonce%3D82031035513841026035%26oauth_signature_method%3DHMAC-SHA1%26oauth_timestamp%3D1368129699%26oauth_token%3D915248383-qr3pkFBxqt1VRoOC5QlZdEmTBQboiui1YNgE3P3G%26oauth_version%3D1.0%26user_id%3D915248383</p> </blockquote>  <p>The <strong>hashString</strong> method then has the job of using <strong>crypto</strong> to hash the data together:</p>  <p><script src="https://gist.github.com/ChrisRisner/5549984.js?file=hashString.js"></script></p>  <p>We end up getting something out that looks like this:</p>  <blockquote>   <p>uH1G+uAbsQxCn5Oe1teTW3N7RFk=</p> </blockquote>  <p><strong>Back to the main method</strong></p>  <p>Now that we’ve generated our signature, we return back to the main method where we set the <strong>oauth_signature </strong>property in the <strong>oauthData</strong> array.&#160; We then create a new variable, <strong>oauthHeader</strong>, which we fill by looping through the <strong>oauthData</strong>.&#160; After that we chop off the leading comma and have a string that looks like this:</p>  <blockquote>   <p>oauthheader: , oauth_consumer_key=&quot;8PDPZfA7KWbXHdDGuSCbeg&quot;, oauth_nonce=&quot;10312863624286267430&quot;, oauth_signature=&quot;tBSYJ7pshewhix9SRPvPnRMflE0%3D&quot;, oauth_signature_method=&quot;HMAC-SHA1&quot;, oauth_timestamp=&quot;1368130031&quot;, oauth_token=&quot;915248383-qr3pkFBxqt1VRoOC5QlZdEmTBQboiui1YNgE3P3G&quot;, oauth_version=&quot;1.0&quot;</p> </blockquote>  <p>This, with the string <strong>OAuth</strong> prepended to it, is finally our <strong>Authorization </strong>header.&#160; </p>  <p><strong>Making the request</strong></p>  <p>The rest of the code is the same as it would have been with v1.0.&#160; We create a request callback that will be called when Twitter responds.&#160; Inside of that callback, we attempt to parse the data and pull out the username which we set on the <strong>result</strong> object before returning to the calling app.&#160; Finally, we use the <strong>request</strong> module to generate a new request and set the <strong>Authorization </strong>header using the value we previously created and then actually make the request.</p>  <p><strong>Conclusion</strong></p>  <p>As you’ve seen, calling into Twitter’s v1.1 API is entirely doable from Mobile Services’ scripting layer, it just takes a good amount of code to do it.&#160; We’ll have a better way of handling all of this code at some point in the future but for now, you should be able to copy and paste most of this.&#160; Remember that you need to replace the Consumer Key, Access Token, Consumer Secret, and Access Token Secret with your own values before you’ll be able to run the script.&#160; </p>