---
layout: post
title: "CountDownLatchs and Android"
date: Mon May 13 2013 13:07:00
commentsOn: true
status: publish
type: post
published: true
categories: [Android, Java, Mobile Services, Azure]
excerpt: "This short tutorial demonstrates how you can use CountDownLatches in your Android applications in order to halt processing on one thread until another thread is finished processing.  Includes source code demonstrating how you can accomplish this."
logoUrl: null
keywords: Android,countdownlatch, synchronization,await,mobile services,azure,reprocess
filepath: 2013-05-13-CountDownLatchs-and-Android.html
disqus_identifier: CountDownLatchs-and-Android
---
<p><img style="float: right; margin: 0px 0px 5px 5px; display: inline" align="right" src="http://chrisrisner.com/upload/android-200.png" />A few weeks ago I was working on an <a title="Android, auth, and Mobile Services" href="http://chrisrisner.com/Authentication-with-Android-and-Windows-Azure-Mobile-Services">Android sample connecting to Windows Azure Mobile Services to do different kinds of authentication</a>.&#160; One of the features of that sample was the ability to ask the user to login if they made a request that required they be authenticated but the token they were using had expired.&#160; After they logged in again, the previous request would then be retried.&#160; Unfortunately, at the time it seemed like I would need to add something custom to the Mobile Services SDK for Android in order to track the previous request and then retry it.&#160; This resulted in the addition of quite a bit of code.&#160; After posting that sample and walking through the changes I made with the SDK team, we found a much easier way to accomplish the task without making any changes to the SDK:&#160; using a <a title="CountDownLatch" href="http://developer.android.com/reference/java/util/concurrent/CountDownLatch.html">CountDownLatch</a>.&#160; </p>  <p><strong>What is a CountDownLatch?</strong></p>  <p>A CountDownLatch is a synchronization aid that enables you to block a thread until the countdown reaches zero.&#160; In other words, you can pause execution of one thread until a second thread says “ok you can finish now”.&#160; How does this help us with the scenario above?&#160; Well, due to the fact that network requests can’t (and shouldn’t) be made on the main (UI) thread, you have to perform these requests on a separate thread.&#160; When we make the first request (with the expired token) the response is handled on a background thread.&#160; From this thread, if we want to make the user log in again, we need to open the login dialog, but we need to jump back to the UI thread to do that.&#160; When we get the response from the login dialog that they’ve successfully authenticated, we then need to update our request with the new token and rerun that request but on a background thread!&#160; That’s a lot of jumping back and forth so I’ve made this diagram in an attempt to simplify things:</p>  <p align="center"><img title="Retry request diagram" alt="Retry request diagram" src="http://storage.chrisrisner.com/images/retry-request-diagram.jpg" /></p>  <p>So as you can see, this is a bit complicated.&#160; My previous solution was to keep a copy of the request that was made and, if we had to re-login the user, to alter that copied request and then reissue it.&#160; At the time I thought this was necessary because Mobile Services requests are wrapped up in the AsyncTask class and you can’t have the same task run twice.&#160; However, I was missing the fact that I could use the same service filter to reissue the request.&#160; That might not make sense right now but I’ll show you some code and it will clear things up for you quite a bit.&#160; </p>  <p><strong>The Code</strong></p>  <p>I’ve taken the code from the previous sample and removed the code not necessary for explaining how this works:</p>  <p><script src="https://gist.github.com/ChrisRisner/5571006.js?file=Countdown.java"></script></p>  <p>This ServiceFilter’s <strong>handleRequest</strong> method will be called prior to any request being made against my Mobile Service.&#160; It uses the <strong>nextServiceFilterCallback</strong> to call <strong>onNext</strong> which will process that request and call the <strong>onResponse</strong> method when it gets a result back.&#160; Inside that <strong>onResponse</strong>, we check for a 401 and if so, we create our <strong>CountDownLatch </strong>with an initial value of 1 (since we’re only waiting on one operation to complete).&#160; We then use the current activity to call <strong>runOnUiThread</strong> and ask the user to login again.&#160; When the <strong>onCompleted</strong> method of the login is called, if there wasn’t an exception, we can update our request object (left out for brevity) and call <strong>latch.coundDown()</strong>.&#160; This call basically says “if anyone called <strong>await()</strong> on this CountDownLatch, you can proceed now!”&#160; Right beneath the block we have to run code on the UI thread, the <strong>onResponse</strong> method continues with a call to <strong>latch.await()</strong>.&#160; So basically, we’re running some code on the UI thread and in the background thread we’re saying “let’s wait for that to be done”.&#160; Once the UI thread is done, we use the same <strong>nextServiceFilterCallback</strong> <strong>onNext</strong> method to process the request.&#160; Now we’ve got the same process we had before working but without needing to track the previous request, request type, table, etc.&#160; Much easier (though a bit to understand).</p>  <p><strong>Conclusion</strong></p>  <p>Using the <strong>CountDownLatch</strong> gives you an easy way to block a thread and wait for some action to be performed.&#160; This is very useful if you’re doing background processing of any sort.&#160; In this specific situation, it saves us from needing to keep track of quite a few variables so we can reprocess a request.&#160; I’ve updated the sample code for the <a title="Android auth demo" href="http://chrisrisner.com/Authentication-with-Android-and-Windows-Azure-Mobile-Services">authentication demo</a> so it now includes this code instead of the old version that required SDK changes and you can <a title="Android auth and mobile services" href="http://chrisrisner.com/Authentication-with-Android-and-Windows-Azure-Mobile-Services">read more about it here</a>.</p>