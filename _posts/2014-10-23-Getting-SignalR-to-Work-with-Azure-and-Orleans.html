---
layout: post
title: "Getting SignalR to Work with Azure and Orleans"
date: Thu Oct 23 2014 14:18:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Games, Azure, Web]
excerpt: "This post covers getting SignalR working with Azure and project Orleans."
logoUrl: null
keywords: Orleans,SignalR,Azure,Real-time,grain.grains,silos,silo,hub
filepath: 2014-10-23-Getting-SignalR-to-Work-with-Azure-and-Orleans.html
disqus_identifier: Getting-SignalR-to-Work-with-Azure-and-Orleans
---
<p><img title="SignalR" style="margin: 0px 0px 5px 5px; display: inline" alt="SignalR" src="http://storage.chrisrisner.com/images/logo-signalR.png" width="154" align="right" height="154" />I just recently posted the <a title="AdventureTerre Source Code" href="https://github.com/ChrisRisner/AdventureTerre">source code</a> and <a title="Adventure Terre" href="http://adventureterre.cloudapp.net/">link to the Adventure style game</a> I built with Orleans and Azure.&#160; Today I’d like to talk briefly about how I got <a title="SignalR" href="http://signalr.net/">SignalR</a> to work.&#160; If you haven’t looked at SignalR before, it’s a very cool library which makes it easy to add real-time functionality to your applications.&#160; In more simple terms, it makes it possible for you to push information from your server to the client instead of having to ask for updates.&#160; This is really powerful because you can deliver instant updates to the client when a change happens on the server.&#160; </p>  <p>To add SignalR to my sample, I worked off of the <a title="GPSTracker Sample" href="https://orleans.codeplex.com/wikipage?title=GPS%20Tracker&amp;referringTitle=Samples%20Overview">GPSTracker sample</a> provided with Orleans.&#160; One issue I had to figure out that the GPS Tracker doesn’t cover is getting things to work on Azure.&#160; As it turns out (and I’ll provide more detail below) there weren’t any big changes just because we were on Azure, however, figuring out how to open the path from Worker Roles to Web Roles for SignalR was something I had deal with.</p>  <p><strong>SignalR in AdventureTerre</strong></p>  <p>For AdventureTerre, there were a few different scenarios I thought SignalR might be useful.&#160; If you go play the game right now, I didn’t leave any of them in but turning them on is easy.&#160; The first scenario and the one I implemented was having monsters (as well as NPCs) have the ability to move between rooms.&#160; The way this works is that, if specified that they should be able to move, an <a title="Orleans Timers" href="https://orleans.codeplex.com/wikipage?title=Timers%20and%20Reminders&amp;referringTitle=Advanced%20Concepts">Orleans timer</a> is created on the grain telling it to attempt to move very couple of minutes.&#160; The timer causes a method on the Monster / NPC grain to fire which will randomly choose a direction and then, if there is a room in that direction, will move the monster / NPC.&#160; When this happens a message is sent to any players in the old room letting them know the character left the room and a different message is sent to any players in the new room letting them know the character has entered the room.&#160; Pretty simple but a much better experience than looking at a room one second and not seeing a monster there and looking again a second later and seeing one there.&#160; There were other possible scenarios I thought of including having the monsters / NPCs randomly say something to players in the room as well as having players say things to one another (right now the game is strictly single player).&#160; </p>  <p><strong>SignalR and the Web Layer (Web Roles)</strong></p>  <p>Getting SignalR to work with Orleans requires a little more thought due to how SignalR and Grains work.&#160; When a client (our website) opens, we use JavaScript to connect to a Hub running in our web application.&#160; Upon connecting to the Hub, the hub adds the client’s connection to a group based off of a cookie value (which is also tied to the player).&#160; These groups are how messages are later sent.&#160; Essentially the hub is told “send this data to this recipient” and the hub does that based off the group they’re in.&#160; (since the cookie is tied to the player, when we want to deliver a message to the player, we tell the hub to deliver to the group also tied to the cookie value)&#160; let’s take a look at some of the code for this.&#160; First the JavaScript in our website:</p>  <p><script src="https://gist.github.com/ChrisRisner/bf96261b384f55fd0c29.js?file=client.js"></script></p>  <p>This is pretty straight forward.&#160; We create a hub tied to a <strong>PlayerHub</strong> and start it which connects it to the Hub on the server.&#160; We also define the methods <strong>playerUpdate</strong> and <strong>playerUpdates</strong>.&#160; Now let’s look at the <strong>PlayerHub </strong>which is a Controller in the web app:</p>  <p><script src="https://gist.github.com/ChrisRisner/bf96261b384f55fd0c29.js?file=PlayerHub.cs"></script></p>  <p>Here again we see the update methods though we specify who the message should be sent to (the Recipient field is the cookie value mentioned above).&#160; The <strong>OnConnected</strong> method makes sure it’s not a <strong>Grain</strong> connecting to the hub, and if it isn’t, adds the connection to a Group based off the cookie value.&#160; From the web app side, that’s all we need to do (you also need to reference the SignalR JS libraries and the SignalR NuGet where appropriate but I’ll leave that up to you).</p>  <p><strong>SignalR and the Orleans Silo Layer (Worker Roles)</strong></p>  <p>If we were just triggering pushes to our client when something happened in our Web Roles, we wouldn’t need to worry about anything else.&#160; However, our <strong>Grains</strong> and <strong>Silos</strong> are running in Worker Roles.&#160; Those Worker Roles don’t have any concept of our hubs or the connections they have to our clients.&#160; In order to deal with this, we add a <strong>PushNotifierGrain</strong> which handles talking from our <strong>Silos</strong> back to our Web Roles.&#160; Let’s first look at the interface, <strong>IPushNotifierGrain</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/bf96261b384f55fd0c29.js?file=IPushNotifierGrain.cs"></script></p>  <p>The important method here is the on that sends a message to a recipient.&#160; Let’s look at the implementation:</p>  <p><script src="https://gist.github.com/ChrisRisner/bf96261b384f55fd0c29.js?file=PushNotifierGrain.cs"></script></p>  <p>There’s a lot going on here but it’s all pretty easy to understand.&#160; The private vars <strong>hubs</strong> and <strong>messageQueue</strong> keep track of our hub references and a queue of messages to deliver respectively.&#160; <strong>ActivateAsync</strong> creates a timer to regularly flush (send out) messages, refresh our hubs, and creates a timer to refresh the hubs every once in a while.<strong>&#160; RefreshHubs</strong> goes through every instance and gets an endpoint based off of the <strong>InternalSignalR</strong> key.&#160; Once it does that it goes through and removes all old hubs and adds new ones.&#160; The rest of the methods should be pretty easy to understand.&#160; </p>  <p><strong>Sending a message</strong></p>  <p>When we want to deliver a message to a specific player it’s very easy to do so:</p>  <p><script src="https://gist.github.com/ChrisRisner/bf96261b384f55fd0c29.js?file=push.cs"></script></p>  <p>In this case, we’re first getting access to the only <strong>PushNotifierGrain</strong> ever used (we’re always using the one with the ID of zero).&#160; We’re then pulling out all of the players in the current room and getting their primary key (a GUID created with the above mentioned cookie).&#160; We can then call the <strong>SendMessage</strong> method on our <strong>PushNotifierGrain </strong>and pass in the message we want to deliver and the Guid we want to deliver it to.&#160; Once we call that, the <strong>PushNotifierGrain</strong> loops through all of the Hubs that it can connect to and sends the message to that hub.&#160; This means we’re sending our message to every hub (so each Web Role).&#160; It’s then up to the hubs (web role) to deliver the message if a client has registered with the hub with the cookie.&#160; So in the end only one hub will actually deliver the message down to the single client that should receive it!</p>  <p><strong>The hard part: Exposing the endpoint</strong></p>  <p>As I mentioned up near the top, it was pretty easy to take most of that from the <a title="GPS Tracker Sample" href="https://orleans.codeplex.com/wikipage?title=GPS%20Tracker&amp;referringTitle=Samples%20Overview">GPS Tracker</a> sample and adapt it to AdentureTerre.&#160; However, pushing it to Azure lead to an issue:&#160; there was no connection open for the Worker Roles to talk to the Web Roles.&#160; I spent way too much time trying to figure this out.&#160; The key to figuring out the problem was the name of the endpoint we’re looking for in the <strong>RefreshHubs </strong>method: <strong>InternalSignalR</strong>.&#160; This didn’t exist anywhere.&#160; As it turned out, this needs to be specified in the Azure deployment project’s <strong>ServiceDefinition.csdef</strong> file.&#160; You just need to add a new internal endpoint to the Site Bindings and the Endpoints:</p>  <p><script src="https://gist.github.com/ChrisRisner/bf96261b384f55fd0c29.js?file=ServiceDefinition.csdef"></script></p>  <p><strong>Summary</strong></p>  <p>And that’s pretty much it.&#160; Now not only can we “talk back” to our clients from the web but we can trigger updates from our <strong>Grains</strong> as well.&#160; Our application can be really interactive now.&#160; To see the SignalR stuff in action, all you need to do is change the <strong>movesRandomly </strong>flag of any of the characters to <strong>true</strong>.&#160; Then if you’re in the same room when a character tries to enter or leave that room, you’ll get a message pushed to you!</p>