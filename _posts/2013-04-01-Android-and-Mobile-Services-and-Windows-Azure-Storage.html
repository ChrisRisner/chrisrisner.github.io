---
layout: post
title: "Android and Mobile Services and Windows Azure Storage"
date: Mon Apr 01 2013 09:29:05 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Android, Azure, Java, Mobile Services]
excerpt: "This article walks developers through how to program an Android app that uses Windows Azure Mobile Services to talk with Table and Blob Storage."
logoUrl: null
keywords: Mobile Services,Android,java,Azure,Server,Storage,Table,Blob,connect mobile services,Windows Azure,Windows Azure Storage,azure module
filepath: 2013-04-01-Android-and-Mobile-Services-and-Windows-Azure-Storage.html
disqus_identifier: Android-and-Mobile-Services-and-Windows-Azure-Storage
---
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" title="Mobile Services with Android" alt="Mobile Services with Android" align="right" src="http://storage.chrisrisner.com/images/wams-logo-android.jpg" />This article is the companion to one I just <a title="Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/Mobile-Services-and-Windows-Azure-Storage">posted about connecting Mobile Services to Windows Azure Table and Blob Storage</a>.&#160; Prior to taking a look through this article and the mentioned code, I would go through the <a title="Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/Mobile-Services-and-Windows-Azure-Storage">original article</a> on Mobile Services and Windows Azure Storage.&#160; This article will cover how to connect the Mobile Service we set up there with an Android client using the Mobile Services SDK for Android.&#160; All of the source code for this Android app is <a title="Android and Mobile Services App Source Code" href="https://github.com/WindowsAzure-Samples/Android-MobileServices-Storage">available here in GitHub</a>.&#160; Since this app deals with talking to Table and Blob Storage through Mobile Services, I’m only going to highlight here when we’re talking to Mobile Services from Android and maybe a few other important pieces.&#160; If you want to see how the entire app works (such as how we display table names and blob names in a table view) take a closer look at the source code.</p>  <p><strong>Before you run the app</strong></p>  <p>The first thing you need to do before you run this app is adjust the constructor method for the <strong>StorageService </strong>class to use your Mobile Service’s URL and Application Key.&#160; You can grab these by logging into the Windows Azure portal, going to your Mobile Service, and clicking the <strong>MANAGE KEYS</strong> button when viewing your service’s dashboard.&#160; Those values go into the <strong>new MobileServiceClient(…</strong> method call.&#160; The second thing you need to do is actually download a forked version of the <a title="Forked Azure Mobile Services SDK" href="https://github.com/ChrisRisner/azure-mobile-services">Android Mobile Services SDK</a>.&#160; I’ll address this in more detail below in the <strong>Parameters Support </strong>section.&#160; Once you’ve downloaded that version of the SDK, import the Android version (<strong>sdk/android/src/sdk/</strong>) into Eclipse and then reference it from the StorageDemo Android project.</p>  <p><strong>The Storage Service</strong></p>  <p>All of the “action” for talking to our Mobile Service is done inside of the <strong>StorageService</strong> class.&#160; For that reason, the majority of the code we’ll look at today is from that class.&#160; The first thing we’ll look at is the constructor method for the class:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=constructor.java"></script></p>  <p>As mentioned above, you’ll need to set the <strong>mobileserviceurl</strong> and <strong>applicationkey</strong> to your Mobile Service’s before running.&#160; After that, we’re initializing our local tables so we can use them to access the tables in our Mobile Service. Unlike the quick start application or most tutorials with Mobile Services, the variable type for all of the table variables is not a <strong>MobileServiceTable&lt;ClassType&gt;</strong> that is strongly typed to a class in my project.</p>  <p><strong>Typed vs untyped data</strong></p>  <p>As I said, most of the examples you’ll see of working with Mobile Services for Android demonstrate using strongly typed objects that have serialization attributes set so Mobile Services will know how to serialize and deserialize them.&#160; Also, MobileServices uses the object’s class name for the table name.&#160; However, it’s also possible to use untyped data when talking with Mobile Services.&#160; One of the program managers working on Mobile Services, Yavor Georgiev, actually has a <a title="Typed and untyped data with Android and Mobile Services" href="http://hashtagfail.com/post/44606054459/mobile-services-android-typed-untyped">great article all about using typed and untyped data</a> with the Android Mobile Services SDK.&#160; The point is that in these samples we’re not using any typed data.&#160; This is optional as we could generate a typed class that represents the data we get back for tables, each specific table’s data, containers, and blobs.&#160; However, since we’re making a generic solution that will work with any table data, we’re just going to use the <strong>MobileServiceJsonTable</strong>.&#160; Just to make sure I’m perfectly clear, you do NOT have to use MobileServiceJsonTable here and can used typed classes, I’m not typing anything so this example is capable of loading data from <em>any</em> storage account.&#160; With all that said, let’s start looking at interacting with our Mobile Service.</p>  <p><strong>Reading tables</strong></p>  <p>Since we only need the table names when we load our tables, we’re just looping through them and building an arraylist of the <strong>TableName</strong> properties for reach result:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=getTables.java"></script></p>  <p>We’re actually getting back more information so we could track all of it if we wanted to.&#160; After we load the tables, we’re broadcasting an action named <strong>tables.loaded</strong>.&#160; Because I wanted all of my data stored in one location (<strong>Storage Service</strong>), I needed a way to let a different part of the application know that the data was loaded.&#160; In this case, the <strong>TablesActivity </strong>class has registered to be notified whenever this action is broadcasted so when that is fired, the list view that’s part of that activity will rebind to the loaded data.</p>  <p><strong>Creating tables</strong></p>  <p>Adding tables is actually quite easy:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=addTable.java"></script></p>  <p>We just need to generate a new <strong>JsonObject</strong> and put the table name in as a property before calling the <strong>insert</strong> method.&#160; When the table is created we’re recalling the <strong>getTables </strong>method above.&#160; This is just a quick way to trigger the list view to be reloaded.&#160; We’re also hitting the server for all of the tables again though we could avoid this by just inserting the new table’s name into the local array of table names and broadcasting the <strong>tables.loaded</strong> action.</p>  <p><strong>Deleting tables</strong></p>  <p>Deleting tables is a little interesting.&#160; We HAVE to send over a <strong>JsonObject</strong> with an <strong>id </strong>property.&#160; If this isn’t included, the SDK will say it can’t try to delete the data.&#160; Additionally, when the <strong>delete</strong> script is called on the server, not all of the data we put into the <strong>JsonObject</strong> is included.&#160; In fact, only the <strong>id </strong>property is included.&#160; For that reason, we have to pass the name of the table we want to delete in as parameters:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=deleteTable.java"></script></p>  <p>Again when that’s done, we call <strong>getTables</strong> to trigger fetching the tables and reloading the list view.&#160; There is actually something very interesting about us passing the parameters in to this method, but I’ll address that at the end of the article (if you missed the note above about getting the application to compile or feel like skipping ahead and want to know why things aren’t working, read the note below about <strong>Parameter Support</strong>).</p>  <p><strong>Reading table rows</strong></p>  <p>To read the rows that are part of the selected table, we need to specify the table name:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=getTableRows.java"></script></p>  <p>Reading data from a Mobile Service table requires us to call the <strong>execute</strong> method.&#160; One of the overrides for this allows us to pass in a <strong>MobileServiceQuery</strong>.&#160; We can generate this by calling the <strong>parameter</strong> method on our <strong>MobileServiceJsonTable</strong>.&#160; Doing so with the table name will set the table name to be a property on the <strong>request.parameters</strong> object in our server side script.&#160; At the end, we broadcast the <strong>tablerows.loaded</strong> action which will be received by the <strong>TableRowsActivity </strong>and trigger reloading the list view.</p>  <p><strong>Inserting table rows</strong></p>  <p>Adding a table row requires us to do two things: fill a <strong>JsonObject</strong> with all of the data for the row, and pass the table name in as a parameter:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=addTableRow.java"></script></p>  <p>The data for the table row is passed in as a list of key-value pairs and is then looped through and added to the <strong>JsonObject</strong>.&#160; We next create a new list of key-value pairs to act as the parameters and add the table name to it.&#160; We then call the <strong>insert</strong> method on the <strong>mTableTableRows</strong> property.&#160; When that gets the data back we recall <strong>getTableRows</strong> to repull the data (again an unnecessary step if we want) which will trigger the <strong>tablerows.loaded</strong> action.</p>  <p><strong>Deleting table rows</strong></p>  <p>Deleting a table row, much like deleting a table, requires passing over an object with the <strong>id</strong> property and then passing the other information in as parameters:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=deleteTableRow.java"></script></p>  <p>The parameters required here are the table name, Partition Key, and Row Key.&#160; When the <strong>delete </strong>call comes back, we call <strong>getTableRows</strong> which will reload the data.</p>  <p><strong>Updating table rows</strong></p>  <p>Updating a table row is very close to inserting a table row:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=updateTableRow.java"></script></p>  <p>One thing we have to do differently is add an <strong>id </strong>field.&#160; This is interesting because each table row actually has an <strong>id</strong> field that is set automatically when you insert to Table Storage.&#160; However, we’re not showing this in the UI or passing it over (it’s unnecessary for Table Storage). HOWEVER, you must pass over a non-zero <strong>id</strong> field in the data item to the <strong>update</strong> method or it won’t work.&#160; When that call comes back, we call <strong>getTableRows </strong>again to reload the table rows.&#160; That’s a wrap on tables, now we can look at blobs.</p>  <p><strong>Reading containers</strong></p>  <p>Getting the containers is pretty much the same as getting tables: </p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=getContainers.java"></script></p>  <p>After getting the results, we loop through them and just pull out each item’s container name.&#160; Here we broadcast <strong>containers.loaded</strong> which triggers <strong>ContainersActivity</strong> to reload it’s listview.</p>  <p><strong>Creating containers</strong></p>  <p>Adding a container is very similar to adding a table except we’re also sending in a parameter:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=addContainer.java"></script></p>  <p>The parameter specifies if the container we’re creating is public or not.&#160; If the container is created as public, we’ll be able to load up the blobs inside of it without needing a Shared Access Signature (SAS, but more on that later).</p>  <p><strong>Deleting containers</strong></p>  <p>Deleting containers is just like deleting tables:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=deleteContainer.java"></script></p>  <p>We pass over a zero <strong>id</strong> as the <strong>JsonObject</strong> and then pass over the container name as a parameter.&#160; When the call to <strong>delete</strong> comes back, we then call <strong>getContainers </strong>again to refetch the containers and trigger the reload the list view.</p>  <p><strong>Reading blobs</strong></p>  <p>Getting the blobs is very simple as we just pass over the container name we want to get the blobs for:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=getBlobsForContainer.java"></script></p>  <p>However, once we get the data back, things are a little more complicated.&#160; We are storing an array of the names for each of the blobs (to more easily bind to the list view) as well as an array of the actual Json data for each blob to make it a little easier to load the blob (more on that later too).&#160; Once we’ve looped through the blobs, we broadcast the <strong>blobs.loaded</strong> method which triggers <strong>BlobsActivity</strong> to reload it’s listview.</p>  <p><strong>Inserting blobs</strong></p>  <p>Creating new blobs is handled a little bit interestingly.&#160; In order to create a blob, our Mobile Service tells Blob Storage it wants to create a new blob with a specified container name and blob name.&#160; It does this by generating a Shared Access Signature (SAS) which we can use as part of a URL to then post the blob data from the client.&#160; So, from the client we call <strong>getSasForNewBlob</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=getSasForNewBlob.java"></script></p>  <p>This method sends over a zero for the <strong>id</strong> and then specifies the container name and blob name as parameters.&#160; When this is done, we save the results (which includes the SAS URL) from the server, and then broadcast the <strong>blob.created</strong> action.&#160; This triggers <strong>BlobActivity</strong> to then upload the data to the SAS URL endpoint that was returned from the server.&#160; You can see how this is done by looking at the <strong>BroadcastReceiver </strong>and the <strong>ImageUploaderTask</strong> in the <strong>BlobActivity</strong> class.&#160; </p>  <p><strong>Loading individual blob data</strong></p>  <p>If the blob we’re looking at isn’t public, then we can’t just use it’s URL property to load the blob data (in the case of the sample app, we’re dealing with images when it comes to adding new blobs).&#160; Instead we have to get a “readable” SAS URL which will then briefly allow us to read the blob’s data (and load the image data).&#160; For that reason there is a <strong>getBlobSas</strong> method:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=getBlobSas.java"></script></p>  <p>This method is nearly the exact same as the <strong>getSasForNewBlob </strong>method above (because on the sever side we get a read+write SAS URL) except for the action broadcasted.&#160; Here we’re broadcasting <strong>blob.loaded</strong>.&#160; This is received by the <strong>BlobDetailsActivity </strong>class which will then use the SAS URL retrieved to load the image data (look at <strong>BlobDetailsActivity</strong>’s <strong>ImageFetcherTask</strong>).&#160; </p>  <p><strong>Deleting blobs</strong></p>  <p>Deleting blobs is similar to deleting tables or containers:</p>  <p><script src="https://gist.github.com/ChrisRisner/5268441.js?file=deleteBlob.java"></script></p>  <p>We pass over a zero <strong>id</strong> and then put the container name and blobs name in the parameters that get sent over.&#160; We then call <strong>getBlobsForContainer </strong>to reload the blobs for the container.</p>  <p><strong>Finished with storage</strong></p>  <p>That’s all we need to do from the client side.&#160; Some of these method calls you’ve seen don’t really do anything differently than calls to Mobile Services when we’re using SQL Database storage normally.&#160; If we were using typed classes for Tables, Containers, and Blobs (which we could do since their data fields will be the same) things would look even more similar to normal usage.&#160; While for “generic data” you wouldn’t be able to use a typed class (necessarily) for the table rows data, in theory you’ll know exactly what data fields your tables have within them and could use a typed class for each of your different tables if you wanted to.&#160; </p>  <p><strong>Parameters Support</strong></p>  <p>Unfortunately at the time of writing, the Android Mobile Services SDK doesn’t support sending optional parameters over when making insert, update, or delete requests.&#160; Thankfully I forked the repo and have added the ability to send parameters.&#160; I’m in the process of finishing up some unit tests that will test the new functionality before I can do a pull request against the official Android SDK and hopefully get that merged in.&#160; For now, you can access the <a title="Forked Android Mobile services SDK" href="https://github.com/ChrisRisner/azure-mobile-services">forked SDK with parameter support here</a>.&#160; In order to use it, you’ll need to import the Android SDK into Eclipse and then reference it from your Android project (or the StorageDemo app in the case of this sample).&#160; </p>  <p><strong>Conclusion</strong></p>  <p>Today we looked at how to implement a client that connects to a Mobile Service that uses Table and Blob Storage. Some aspects of it are no different from using normal SQL Database storage. Some of it requires a few additional steps. With the knowledge from this article and the <a title="Mobile Services and Windows Azure Storage" href="http://chrisrisner.com/Mobile-Services-and-Windows-Azure-Storage">server side one</a>, you should now know how to comfortably combine SQL Database, Table, and Blob Storage. A good knowledge of Blob Storage and getting SAS URLs (and how to upload blobs with them) is important even if you stick to SQL Storage since it, and the JSON that is used between the client and Mobile Services, isn’t really meant for file storage. Good luck and remember that the source code for this and the server side scripts is all <a title="Android Mobile Services and Storage Source Code" href="https://github.com/WindowsAzure-Samples/Android-MobileServices-Storage">available here on GitHub</a>.</p>