---
layout: post
title: "Building a Text Adventure with Azure and Orleans"
date: Wed Oct 22 2014 14:13:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [.Net, Azure, Javascript, Web]
excerpt: "This post talks about building an Adventure style text game using Azure and the Orleans framework from Microsoft.  "
logoUrl: null
keywords: Adventure,Orleans,Text game,Interactive Fiction,zork,colossal adventure,azure,paas,cloud services,grains,silos
filepath: 2014-10-22-Building-a-Text-Adventure-with-Azure-and-Orleans.html
disqus_identifier: Building-a-Text-Adventure-with-Azure-and-Orleans
---
<p><img title="Colossal Adventure" style="margin: 0px 0px 5px; display: inline" alt="Colossal Adventure" src="http://storage.chrisrisner.com/images/colossaladventure.gif" align="right" />Back in May of this year, we did an <a title="Orleans Episode on Cloud Cover" href="http://channel9.msdn.com/Shows/Cloud+Cover/Episode-142-Microsoft-Research-project-Orleans-simplify-development-of-scalable-cloud-services">episode on Cloud Cover</a> focusing on <a title="project Orleans" href="http://blogs.msdn.com/b/dotnet/archive/2014/04/02/available-now-preview-of-project-orleans-cloud-services-at-scale.aspx">project Orleans</a>.&#160; Orleans is a project created by Microsoft Research that provides an easy way to build distributed high-scale computing applications.&#160; You can build these without having to spend months learning and understanding complex concurrency and scaling patterns which is always nice.&#160; If you’ve done .NET development and are familiar with the awesomeness of async / await, picking up project Orleans is very easy to do.&#160; Orleans does this using the actor model which I’ll talk more about in a minute.&#160; One of the other great things about Orleans is that it’s built from the ground-up with the cloud in mind.&#160; So getting it on to Azure is pretty easy to do.&#160; </p>  <p>TLDR: You can play the <em>game</em> here: <a title="http://adventureterre.cloudapp.net/" href="http://adventureterre.cloudapp.net/">http://adventureterre.cloudapp.net/</a></p>  <p>TLDR: You can check out the source code <a title="AdventureTerre Source Code" href="https://github.com/ChrisRisner/AdventureTerre">here</a>.</p>  <p>One of the samples in the Orleans release is a simple text adventure game named, <a title="Adventure sample" href="https://orleans.codeplex.com/wikipage?title=Adventure&amp;referringTitle=Samples%20Overview">Adventure</a>.&#160; This game is in the same style as <a title="Zork" href="http://en.wikipedia.org/wiki/Zork">Zork</a> or <a title="Colossal Adventure" href="http://en.wikipedia.org/wiki/Colossal_Cave_Adventure">Colossal Adventure</a> which many people are familiar with (if you aren’t, you can actually <a title="Play Colossal Adventure on Halt and Catch Fire" href="http://www.amctv.com/shows/halt-and-catch-fire/colossal-cave-adventure/landing">play Colossal Adventure on AMC’s Halt and Catch Fire website</a>!).&#160; The general idea is that everything is text based.&#160; Players read about their surroundings and then type in what they want to do.&#160; These text adventures, called <a title="Interactive Fiction" href="http://en.wikipedia.org/wiki/Interactive_fiction">Interactive Fiction</a>, were some of the first computer games.&#160; I’ve been meaning to get back to doing some more game dev so a little over a month ago, I started on a small side project to make a text adventure game on top of Azure using the Orleans Framework.&#160; I started by combining the <a title="Adventure sample" href="https://orleans.codeplex.com/wikipage?title=Adventure&amp;referringTitle=Samples%20Overview">Adventure sample</a> with the <a title="Azure Orleans Sample" href="https://orleans.codeplex.com/wikipage?title=Azure%20Web%20Sample&amp;referringTitle=Samples%20Overview">Azure sample</a> for Orleans and got the basic Adventure game running on Azure.&#160; Before I go over the details of that, I should explain how Orleans works.</p>  <p><strong>The actor model and Orleans</strong></p>  <p>The <a title="Actor Model" href="http://en.wikipedia.org/wiki/Actor_model">actor model</a> is a model for concurrent-computation set forth by Carl Hewitt in 1973.&#160; Under the actor model, the <em>actor</em> is the sole primitive.&#160; It handles both behavior and state.&#160; Actors interact with other actors and communicate via asynchronous messages delivered via system-generated proxies.&#160; Actors don’t contain other actors but may have a reference to them (though that reference is just used to send messages as opposed to having direct access).&#160; In Orleans, the actors are called <strong>Grains</strong>.&#160; So every actor in the system is it’s own Grain.&#160; In order to <em>contain</em> the grains, Orleans has <strong>Silos</strong>.&#160; As the developer, you don’t develop the silo as much as start a silo.&#160; The Orleans framework then knows how to make use of the silos to contain the grains.&#160; In addition, the “location” where the grains perform all of their actions is within the silo.&#160; When you need access to a grain, you don’t create a new instance using “new” but instead rely on a generated <strong>GrainFactory</strong> to get an activation for a grain.&#160; In this way, grains are never created nor destroyed.&#160; They are activated or deactivated as needed by the system.&#160; Additionally, grains handle their own state storage (with some work on your part in the Grain code) so persistence is transparent to the client making calls into the Grain.&#160; This all may sound a bit confusing but I’ll follow up this post with another explaining more about the architecture of Orleans and the sample I built so it will make more sense.</p>  <p><strong>Azure and Orleans</strong></p>  <p>When it comes to Orleans, Azure is a natural fit for deployment.&#160; Orleans includes a number of <a title="Orleans step-by-step" href="https://orleans.codeplex.com/wikipage?title=Step-by-step%20Tutorials&amp;referringTitle=Orleans%20Documentation">step-by-step tutorials</a> which explain how to get started with Orleans.&#160; One of the most useful is one that <a title="Explaining Cloud Deployment" href="https://orleans.codeplex.com/wikipage?title=Cloud%20Deployment&amp;referringTitle=Step-by-step%20Tutorials">explains cloud deployment</a>.&#160; To deploy to Azure, you essentially map your application onto <strong>Worker</strong> and <strong>Web Roles</strong> inside of Azure Cloud Services.&#160; The <strong>Worker Role(s)</strong> run the Orleans Silos where all of your Grains’ functionality takes place.&#160; The <strong>Web Role(s) </strong>run the client code for your application whether it’s a web site or a web service.&#160; So the web code get’s access to your Grains and request them to perform whatever actions they need.&#160; Orleans is built around C# asynchronous programming so everything uses Async and Await.&#160; So every call you make against a grain is asynchronous and you await it from the client until you get the result.&#160; The great thing about this is that due to the Orleans framework, you get high-scalability and concurrency out of this approach without really needing to know more more than what I just described (there is more to know but I’ll get to that in future posts).&#160; You can optionally tie a <strong>GrainState</strong> to each <strong>Grain</strong>.&#160; When you do this, you can specify a Store where your grains’ state should be persisted.&#160; Orleans includes some built in storage providers that make storage super simple by just applying an annotation (<strong>[StorageProvider(ProviderName=”name”)]</strong>) on your <strong>Grain </strong>classes.&#160; For example, you can very easily start <a title="Grains and Azure Table Storage" href="https://orleans.codeplex.com/wikipage?title=Declarative%20Persistence&amp;referringTitle=Step-by-step%20Tutorials">storing your grains’ state into Azure Table Storage</a> by setting up your store, putting the connection string in your config files, and annotating the classes.&#160; Rather than assume when you want to persist data, Orleans leaves it to you to call <strong>State.WriteStateAsync();</strong> in your <strong>Grain’s </strong>code whenever you want to store the state.&#160; Restoring the state is done automatically whenever you activate a grain that has been idle for too long.&#160; There have been a number of community contributions for storage providers but you can also easily <a title="Custom Storage Providers for Orleans" href="https://orleans.codeplex.com/wikipage?title=Custom%20Storage%20Providers&amp;referringTitle=Step-by-step%20Tutorials">write your own storage provider</a> as well.&#160; You can check out a ton of <a title="Orleans Community Contributions" href="https://github.com/OrleansContrib">community contributions for Orleans here</a>.</p>  <p><strong>Adventure Terre</strong></p>  <p>The basic game sample doesn’t have a TON of functionality.&#160; Out of the box it includes the following:</p>  <ul>   <li>View a description of a room </li>    <li>Move from room to room </li>    <li>Pick up and drop things </li>    <li>Kill monsters if you have the right item </li> </ul>  <p>This is enough to show the concept but isn’t really enough to make a game.&#160; To make the game a bit more full fledged I added the following to the public source release:</p>  <ul>   <li>Store a game state (essentially a collection of string-booleans to track individual flags) </li>    <li>Descriptions of rooms, monsters, and NPCs that are shown based off of flags </li>    <li>Ability to set flags when a descriptor is shown </li>    <li>Ability to make NPCs and Monsters move throughout the world in random directions (using Orleans timers) </li>    <li>Ability to send messages down to Players using SignalR (this was really cool to get going so I’ll talk about this in a future post) </li>    <li>Ability to speak to NPCs and Monsters </li>    <li>Non-Playable Characters (essentially monsters that can’t be killed) </li>    <li>Ability to specify where monsters and NPCs should start in the world </li>    <li>Ability to change directions a player can move in based off of the game state flags </li>    <li>Ability to specify different descriptions for items based off of flags </li>    <li>Ability to specify flags that should change when items are used (and how they can be used) </li>    <li>Ability to specify State Change Actions (things that should occur when flags are changed) </li> </ul>  <p>So I added a ton of features.&#160; I actually added a few more features to the non-public release but very little functionality on top of the above.&#160; The majority of the time was spent working on the above as opposed to the story (that will be apparent if you give it a try).&#160; </p>  <p><strong>AdventureTerre Architecture</strong></p>  <p>I’ll give a little detail today on what the architecture of the game looks like to hopefully provide more detail on how something is built with Orleans.&#160; As mentioned above, everything is a <strong>Grain</strong>.&#160; So in this game the following <strong>Grains</strong> exist:</p>  <ul>   <li>Players </li>    <li>Rooms </li>    <li>Monsters </li>    <li>NPCs </li>    <li>GameState </li>    <li>PushNotifiers (I’ll cover this in the future when I talk about SignalR) </li> </ul>  <p>For every player a <strong>PlayerGrain</strong> is generated and it keeps track of the rooms, monsters, NPCs, and game state.&#160; When a request comes in, the <strong>PlayerGrain</strong> figures out what needs to be done and calls out to the other grains.&#160; All of these <strong>Grains</strong> have interfaces which implement some form of <strong>IGrain</strong> and specify an interface that extends <strong>IGrainState</strong>.&#160; All of the grains also specify that they use the <strong>AzureStore</strong> so that whenever their data needs to be written or read, Azure Table Storage is used.&#160; </p>  <p>That all happens within the <strong>Worker Roles</strong>.&#160; However, players don’t have any direct interaction with those roles.&#160; Instead, when you want to play the game, you go to a <a title="AdventureTerre" href="http://adventureterre.cloudapp.net/">website</a> running in the <strong>Web Roles</strong>.&#160; The interface the player plays in resembles a terminal window (yay nostalgia) which runs locally with JavaScript.&#160; Every command is passed to a web service exposed as part of the web site.&#160; That web service handles getting the <strong>PlayerGrain</strong> and calling whatever actions on the grain are necessary. </p>  <p><strong>Design Considerations</strong></p>  <p>While I’m happy to consider myself done with this sample for now, there are a number of things I did that if I had thought things out better at the beginning or had more time now, I’d change.&#160; First, the original sample treated <strong>Things</strong> (items like weapons and food) not as <strong>Grains</strong>, but objects either in a <strong>RoomGrain</strong> or on a <strong>PlayerGrain</strong>.&#160; One feature I added to the final game was the ability to hide and unhide items.&#160; Leaving items as objects in the State of Players and Rooms made this more difficult than if they had been <strong>Grains</strong> as well.&#160; Another change I’d make was how I treated the<strong> GameStateGrain</strong>.&#160; Originally there was just a dictionary on the <strong>PlayerGrain</strong> that contained the state.&#160; While trying to diagnose an issue with await / async (more on this in the future) I moved the dictionary into it’s own <strong>Grain</strong>.&#160; This worked, and still works, but did make a few things more complicated.&#160; There were a few other pain points I’d change but for now, it works and it’s being shipped.</p>  <p><strong>The Game</strong></p>  <p>The game itself ended up being quite small (definitely smaller than Zork for example) but showed several different capabilities and it works.&#160; If you play it, you’ll easily get though doing absolutely everything there is in less than 20 minutes.&#160; I’m hoping this will spur me to get back into actual game development.&#160; For now, you can pull down the source code and deploy it yourself to Azure by going <a title="AdventureTerre Source Code" href="https://github.com/ChrisRisner/AdventureTerre/tree/master">here</a>.&#160; Finally, I encourage everyone to go <a title="Adventure Terre Game" href="http://adventureterre.cloudapp.net/">play the game</a> for a few minutes and remember that everything is running in a super scalable backend powered by Azure.&#160; </p>