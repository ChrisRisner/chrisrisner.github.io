---
layout: post
title: "Mobile Geolocation Apps with Windows Azure Websites Part 5: Adding New Points of Interest in Android"
date: Mon Sep 24 2012 09:17:00
commentsOn: true
status: publish
type: post
published: true
categories: [Azure, Android, Java, Mobile]
excerpt: "This article walks through finishing our mobile geolocation Android application by giving users the ability to post new points of interest.  Included is a walk through of getting a Shared Access Signature to securely upload a file to Windows Azure Blob Storage and then storing a reference to that file in the database."
logoUrl: null
keywords: Android,Eclipse,Java,Windows Azure,Azure,PHP on Azure,Mobile connectivity to Windows Azure,Android Azure,Geolocation,Geospatial,Walkthrough,Tutorial,POST,Blob Storage
filepath: 2012-09-24-Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-5--Adding-New-Points-of-Interest-in-Android.html
disqus_identifier: Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-5--Adding-New-Points-of-Interest-in-Android
---
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" title="Windows Azure and iOS Mapping" alt="Windows Azure and iOS Mapping" align="right" src="http://chrisrisner.com/upload/windowsazure-google-maps.jpg" width="266" height="114" />In the <a title="Starting the Android Client" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-4--Displaying-Points-of-Interest-in-Android">previous article</a> in this <a title="Mobile Geolocation Apps with Windows Azure Websites" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites">series</a>, we walked through creating an Android app, adding a MapView to it, and displaying points of interest on it.&#160; When the user’s location changes and when the app first loads, we communicate with the PHP service, which we set up in the first article, to get all of the points of interest within a number of meters from a certain latitude and longitude.&#160; Today we’re going to look at adding new points of interest.&#160; This actually involves an interesting dance between the client application and the cloud.&#160; We’ll discuss that first.&#160; </p>  <p>If you haven’t already done so, you’ll need to go through <a title="Setting up the Geolocation PHP Code" href="http://chrisrisner.com/Mobile-Geolocation-Apps-with-Windows-Azure-Websites-Part-1--The-PHP-Code">part 1 in this series</a> to set up a Windows Azure Website running the PHP service. To do this you will need to have a Windows Azure account. If you don’t already have a Windows Azure account, you can <a title="Free Windows Azure Trial" href="http://aka.ms/MobileGeolocationWithWindowsAzureWebsites">sign up for a free trial here</a>. Once you’ve deployed that site, you can come back and proceed with this walkthrough.</p>  <p>If you would like to jump ahead and just pull down the source code, you can access it in <a title="Geolocation Android Client GitHub Repository" href="https://github.com/WindowsAzure-Samples/Geolocation-Android-Client">this GitHub repository</a>. Note that you’ll still need to follow the instructions in the readme and configure your app.</p>  <p><strong><font size="4">How do we add a point of interest</font></strong></p>  <p>In order to upload an image or video and tie it to a point of interest in our backend, we have to communicate with two different server components: our <a title="Windows Azure Websites" href="https://www.windowsazure.com/en-us/home/scenarios/web-sites/">Windows Azure Websites</a> PHP service and <a title="Windows Azure Blob Storage" href="https://www.windowsazure.com/en-us/home/features/data-management/">Windows Azure Blob Storage</a>. Let’s look at a diagram of the steps to do this and then discuss them:</p>  <p align="center"><img title="Adding a point of interest in Android" alt="Adding a Point of Interest in Android" src="http://chrisrisner.com/upload/geodemo-android-adding-new-poi.jpg" width="494" height="462" /></p>  <p>The first thing we need to do is have our client app communicate with our service running in Windows Azure Website and request a Shared Access Signature (SAS). </p>  <p>A SAS is a way around needing to have the account name and key of our storage account on the local device. If you were to put the account name and key in your client app and someone was able to pull those details out, they could then upload and access whatever they wanted in your storage account. The way around this is by using the SAS. A SAS is created to give an application the ability to upload a file to a storage account without having the name or key. Instead, a server side component has the name and key and requests the SAS from the storage account. This SAS is a URL which expires after a certain period of time (chosen by the server side component) and gives a client application the ability to upload a single file.</p>  <p>So, our client app requests the SAS from our website. The website talks to our storage account and gets the SAS. The SAS is then returned to the client application. The client app can then use the SAS URL to upload a file. After that is done, we save the point of interest (with a reference to the URL of the item uploaded to storage) inside that point of interest. Let’s get to our code and see how we can accomplish this.</p>  <p><strong>Let’s code</strong></p>  <p>Let’s start by adding some new variables to <strong>Constants.java</strong>.&#160; Specifically, we need URLs for getting a SAS and uploading a point of interest.&#160; We also need to keep track of a container name for blob storage.</p>  <p><script src="https://gist.github.com/3759507.js?file=constants2.java"></script></p>  <p>Remember you need to change “yoursubdomain” to whatever URL you set up in the first article in the series.&#160; Next we need to do is start storing the current location whenever it changes in the activity.&#160; Open up <strong>MainActivity.java</strong> and add a private variable that is a <strong>Location </strong>object:</p>  <blockquote>   <p>private Location mCurrentLocation;</p> </blockquote>  <p>Then in the <strong>onLocationChanged </strong>method in the <strong>LocationListener</strong>, start storing the location into that variable:</p>  <p><script src="https://gist.github.com/3759507.js?file=mainActivity onLocationCHanged"></script></p>  <p>Next, let’s add a new <strong>Android Activity </strong>to your project named <strong>AddPointOfInterestActivity</strong>.&#160; You can lead all of the defaults for this activity.&#160; When your’e done you should have a new activity and a layout file tied to it (I’m using the latest version of ADT which gives you a new activity wizard, as opposed to older versions which required you to manually create the class and layout file as well as modify the manifest). We’re not going to do any work in this activity yet, but we’ll come back to it.&#160; Instead, open up the <strong>res/menu/activity_main.xml</strong>.&#160; This class contains the menu options that appear when you tap the menu button inside our app.&#160; We’re going to add a new <strong>item</strong> here:</p>  <p><script src="https://gist.github.com/3759507.js?file=menu.xml"></script></p>  <p>Now if you run the app and tap the menu button, you should see a new option appear:</p>  <p align="center"><img title="new menu option" alt="new menu option" src="http://chrisrisner.com/upload/geodemo-android-menu.jpg" /></p>  <p>Now let’s return to <strong>MainActivity </strong>and override the <strong>onOptionsItemSelected</strong>: </p>  <p><script src="https://gist.github.com/3759507.js?file=mainactivity_optionsmenu.java"></script></p>  <p>Here, you’re checking to see if the menu item tapped was the “Add Point” one, and if so, starting the <strong>AddPointOfInterestActivity</strong>.&#160; Notice that we’re passing the current location in as an extra.&#160; We’re also starting that activity with the <strong>startActivityForResult</strong> method.&#160; We’re doing that so that when we <strong>finish</strong> the <strong>AddPointsOfInterestActivity</strong> it will do a callback into <strong>MainActivity</strong> so that we can refresh the map.&#160; Before we move on to creating a new point of interest, let’s handle the callback that is fired when the new point of interest activity finishes by adding the <strong>onActivityResult</strong> method:</p>  <p><script src="https://gist.github.com/3759507.js?file=mainactivity_onactivityresult.java"></script></p>  <p>We first check the <strong>requestCode </strong>to see if it matches the value sent into <strong>startActivityForResult</strong>.&#160; We then check to see if the <strong>resultCode</strong> matches another value.&#160; This value will be returned from our new point of interest activity if we successfully added a new point.&#160; Normally we would have used a constant for these values but for ease of explanation, I’m just using numbers right in the code.&#160; Finally, if we did create a new point, we reload the points from the server.</p>  <p><strong><font size="4">The UI for Adding a new Point of Interest</font></strong></p>  <p>Let’s open up the layout file that was generated for our activity.&#160; It should be something like <strong>res/layout/activity_add_point_of_interest.xml</strong>.&#160; This layout just has the default “hello world” message in it right now.&#160; Let’s change this UI to allow a user to add a new point of interest.&#160; We’ll need to give the user the ability to do three things:&#160; select an image, get a SAS, and save a point of interest. To do this, we will want a button for the user to select the image, an image view to show that image in, a button to trigger getting the SAS, a text view to show the SAS, and a button to trigger the save.&#160; We’re going to wrap this all in a <strong>ScrollView</strong> since we’re not sure how much room the user will have on their screen.&#160; When you’re done, the xml will look like this:</p>  <p><script src="https://gist.github.com/3759507.js?file=add_poi.xml"></script></p>  <p>If you run your app now and tap the menu button and go to “Add Point” your new screen should look like this:</p>  <p align="center"><img title="geo android new point of interest" alt="geo android new point of interest" src="http://chrisrisner.com/upload/geodemo-android-add-new-poi-screen.jpg" width="242" height="355" /></p>  <p>Now that the UI is done, we’ll do the code behind.</p>  <p><strong><font size="4">Coding adding the point of interest</font></strong></p>  <p>Open back up <strong>AddPointOfInterestActivity.java</strong>.&#160; Let’s first add some private variables we’ll need:</p>  <p><script src="https://gist.github.com/3759507.js?file=addpoi_vars.java"></script></p>  <p>You’ll see where these come in as we proceed.&#160; Next, we have the <strong>onCreate</strong> method:</p>  <p><script src="https://gist.github.com/3759507.js?file=add_poi_onCreate.java"></script></p>  <p>The first thing we do is get references to all of our UI controls and keep track of the <strong>Activity</strong> we’re in.&#160; We then disable the “Get SAS” and “Save Point of Interest” buttons so the user can’t tap them until we’re ready.&#160; Finally we set some <strong>onClickListener</strong>s.&#160; When the user taps the “Select Image” button we are firing a local method named <strong>selectImage</strong>.&#160; The other two buttons show a progress dialog and then execute new tasks.&#160; Let’s look at the image selection first:</p>  <p><script src="https://gist.github.com/3759507.js?file=add_poi_selectImage.java"></script></p>  <p>In <strong>selectImage</strong> we are creating a new <strong>ACTION_GET_CONTENT</strong> intent and telling it to select from images (this will fire the gallery).&#160; Again we’re starting the intent with <strong>startActivityForResult</strong> which let’s us catch it which is what we’re doing in <strong>onActivityResult</strong>.&#160; In the result method, we store the image URI as well as set the URI of the image view.&#160; Finally, we switch the buttons so the user can get the SAS.&#160; Now let’s look at the <strong>GetSASTask</strong> we saw above:</p>  <p>&#160;</p>  <p>This task starts by calling the <strong>getSas</strong> method which is actually a method in the <strong>AddPointOfInterestActivity </strong>class.&#160; When <strong>getSas</strong> returns, we pass the <strong>blobImagePostString</strong> which goes to the <strong>postExecute </strong>method.&#160; <strong>postExecute</strong> will set the returned SAS URL to be the text of the text view in our UI as well as deactivating the “Get SAS” button (so the user can’t get a second one) and enables the “Save Point of Interest” button.&#160; In the <strong>getSas</strong> method, we create a URL using the <strong>kBlobSASUrl</strong> constant formatted with the container name (a container stores blobs (or files)), and the current time in milliseconds (which we’re using as the file name).&#160; We then use <strong>HttpURLConnection </strong>to post to the PHP service and get our SAS URL back.&#160; This is set to the <strong>blobImagePostString </strong>variable and the method completes (which goes back to the <strong>postExecute</strong> method above).&#160; The last thing we have to look at is the <strong>PostPointOfInterestTask</strong>:</p>  <p>&#160;</p>  <p>Here we’re calling a method (part of the <strong>AddPointOfInterestActivity</strong>) named <strong>postPointOfInterestToServer</strong>.&#160; We return the result of that method which is sent to <strong>postExecute</strong>.&#160; If the result was “created” we return the <strong>result code</strong> that is expected back in <strong>MainActivity </strong>if an point is successfully created.&#160; If not, we figure out what the reason was and show a toast to alert the user.&#160; Let’s finish things off with the <strong>postPointOfInterestToServer</strong> method:</p>  <p><script src="https://gist.github.com/3759636.js?file=post_point_of_interest.java"></script></p>  <p>We’ve got a lot going on here so we’ll go step by step.&#160; We first check to make sure the image and location are valid.&#160; We then open up the image file and get the bytes for it.&#160; We then create a <strong>HttpURLConnection </strong>and write the image bytes to the SAS URL.&#160; Provided we get back a 201 response code, we then generate a <strong>JSONObject </strong>with all of our point of interest information in it including the coordinates, ID, type (image or video), URL, and description.&#160; We then use another <strong>HttpURLConnection</strong> to post to our PHP server to let it know we generated a new point of interest.&#160; We return the response message from that to the calling method (which passes it to the <strong>postExecute</strong> method seen above).&#160; </p>  <p><strong><font size="4">Running the App</font></strong></p>  <p>When we run the app, we’ll set our location to be in downtown Seattle, near where we were yesterday.&#160; Currently there are three points of interest.&#160; We’re going to add a fourth.&#160; Let’s follow the flow of adding a new point of interest.&#160; </p>  <p align="center"><img src="http://chrisrisner.com/upload/geo-demo-android-flow.jpg" width="538" height="769" /></p>  <p>We select an image first.&#160; Then we get the SAS URL.&#160; Finally we post it (which handles both uploading the image to blob storage and the point of interest data to our service).&#160; With that done we return the user to the map and refresh the points of interest near our current location.&#160; Now we see that the original point from yesterday and our new point are showing up.</p>  <p><strong><font size="4">Conclusion</font></strong></p>  <p>Today we finished our Android Geolocation app.&#160; In doing so, we made more connections to our PHP service running in Windows Azure Websites in addition to using Windows Azure Blob Storage for storing images.&#160; I hope this has proved informative and has given you some solid understanding of how to create Android applications with geolocation components powered by Windows Azure.&#160; As mentioned at the top, you can access the source code for the <a title="Geolocation Android App code in GitHub" href="https://github.com/WindowsAzure-Samples/Geolocation-Android-Client">full version of this app on GitHub</a>. Remember to configure the subdomains in the <strong>Constants.java</strong> file before trying to run it.</p>