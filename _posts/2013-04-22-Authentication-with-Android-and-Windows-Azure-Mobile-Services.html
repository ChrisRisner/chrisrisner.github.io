---
layout: post
title: "Authentication with Android and Windows Azure Mobile Services"
date: Mon Apr 22 2013 13:13:00 GMT-0700 (PDT)
comments: true
status: publish
type: post
published: true
categories: [Android, Azure, Java, Mobile Services]
excerpt: "This post details how to connect an Android application to a Windows Azure Mobile Service and allow the user to login with Facebook, Google, Microsoft, or Twitter accounts. Additionally, we'll show how to provide the ability to create a new account to login with."
logoUrl: null
keywords: Mobile Services,Azure,authentication,facebook,google,twitter,microsoft,custom auth,social,identity,login,logout,token,userid,caching auth,android,java
filepath: 2013-04-22-Authentication-with-Android-and-Windows-Azure-Mobile-Services.html
disqus_identifier: Authentication-with-Android-and-Windows-Azure-Mobile-Services
---
{% include special/mobile_services_to_apps.html %}

<p><img title="Mobile Services with Android" style="float: right; margin: 0px 0px 5px 5px; display: inline" alt="Mobile Services with Android" align="right" src="http://storage.chrisrisner.com/images/wams-logo-android.jpg" />
<p>
<strong>Update 4/22/2014: Version 1 JWTs have been deprecated.  Make sure you <a href="http://chrisrisner.com/Version-1-of-the-Mobile-Services-JWT-token-has-been-deprecated" title="Update to JWT Creation">check out this post</a> to see how the script for JWT creation needs to be changed.</strong>
<br /><br />
<strong>Update 5-13-2013</strong>: Since writing this I found an easier way to do the retry request that does not require the changes to the SDK.  Please read more about this at this post on <a href="http://chrisrisner.com/CountDownLatchs-and-Android" title="Android and CountDownLatchs">CountDownLatchs</a>.
</p>

This article is the companion to one I just <a title="Server side of authentication and Mobile Services" href="http://chrisrisner.com/Authentication-with-Windows-Azure-Mobile-Services">posted about handling different types of authentication with Windows Azure Mobile Services</a>.&#160; Prior to taking a look through this article and the mentioned code, I would go through the <a title="Authentication and Mobile Services" href="http://chrisrisner.com/Authentication-with-Windows-Azure-Mobile-Services">original article</a> on Mobile Services and auth.&#160; This article will cover how to connect the Mobile Service we set up there with an Android client using the Mobile Services SDK for Android.&#160; All of the source code for this Android app is <a title="Android Authentication with Mobile Services" href="https://github.com/WindowsAzure-Samples/Android-MobileServices-Authentication">available here in GitHub</a>.&#160; I’m going to cover a few different areas in the app in this post: giving users the choice of how to login, creating and logging in with custom accounts, logging users out and returning to the root view controller, caching user tokens so we don’t have to login each time we run the app, and dealing with expired tokens now that we’re caching them.</p>  <p><strong>An updated Android SDK</strong></p>  <p>For a couple of different reasons, I needed to update the Android SDK to complete this sample.&#160; I’m in the process of working on a pull request against the official SDK to get these changes into what you pull down from the portal, but for now you can download the updated SDK from my forked repo in GitHub <a title="Retry Support Android SDK Fork" href="https://github.com/ChrisRisner/azure-mobile-services/tree/RetrySupport">here</a>.&#160; The two additions to the SDK in this fork are the ability to pass query string parameters to insert, update, and delete calls against your Mobile Service tables as well as some code to make it easier / possible to retry requests.&#160; We’ll talk more about this when we get into handling expired tokens.&#160; If you don’t want to provide retry request support you DO NOT need to use the forked SDK.&#160; It’s only required to support retrys.</p>  <p><strong>Giving the user choice</strong></p>  <p>This is one of the easiest things to do from a front end perspective because all you need to do, is give the user the ability to select their authentication provider:</p>  <p align="center"><img title="Provider selection" alt="Provider selection" src="http://storage.chrisrisner.com/images/android-auth-pick-provider.jpg" width="213" height="315" /></p>  <p>All I’ve done is put one button for each provider and then the custom auth at the bottom.&#160; Each of these buttons, except the last, calls the same <strong>OnClickListener</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=loginButtonClick.java"></script></p>  <p>We’re checking to see which button was clicked and setting a provider variable to match the type, then calling <strong>mAuthService</strong>’s <strong>login</strong> method.&#160; <strong>AuthService</strong> is a class that wraps most of the Mobile Service functionality which we’ll be talking about throughout this article.&#160; This method takes in the provider and a <strong>UserAuthenticationCallback</strong>.&#160; This callback is called when the user finishes logging in, or cancels out (or if there is an error).&#160; If there aren’t any issues, we save the user data (which we’ll cover later), and then open the <strong>LoggedInActivity</strong> with an <strong>Intent</strong>.&#160; The <strong>login</strong> method presents the login view of the provider web view, all wrapped up for us.&#160; Let’s talk about what happens when you hit the <strong>Login with Email</strong> button.</p>  <p><strong>Custom auth</strong></p>  <p>When you tap the <strong>Login with Email </strong>button we fire another intent that takes you to <strong>CustomLoginActivity</strong> where the user can enter their username and password:</p>  <p align="center"><img title="custom auth login" alt="custom auth login" src="http://storage.chrisrisner.com/images/android-auth-custom-login.jpg" width="257" height="379" /></p>  <p>Let’s take a look at logging the user in here before we look at registering their account.&#160; When the user taps <strong>Login</strong> we call the following code:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=customLoginButtonClick.java"></script></p>  <p>First we check to see if the username and password fields aren’t empty.&#160; We’re only logging them if they aren’t but we should probably show some indicator to the user.&#160; If there aren’t any issues, we call <strong>authService</strong>’s <strong>login </strong>method but here we’re passing over a username and password instead of the provider.&#160; This override means we’re trying to do custom auth.&#160; In the callback handler we’re doing the same thing as before: saving the user data and loading the <strong>LoggedInActivity</strong>.&#160; Let’ move on to the <strong>Register for Account</strong> button.</p>  <p><strong>Registering accounts</strong></p>  <p>When you tap the <strong>Register for Account</strong> button, we launch the <strong>RegisterAccountActivity</strong>:</p>  <p align="center"><img title="Registering an account" alt="Registering an account" src="http://storage.chrisrisner.com/images/android-auth-register-account.jpg" width="226" height="336" /></p>  <p>Let’s look at what happens when the user taps <strong>Register</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=registerButtonClick.java"></script></p>  <p>The first thing we do is check that all of the fields are filled out.&#160; If not, we’re just logging some information to say they aren’t.&#160; If this was a real app, we’d probably want to give the user a visual cue to know that they need to enter the info.&#160; After that, we check to make sure the password and confirm password are the same.&#160; Finally, we call the <strong>mAuthService</strong>’s <strong>registerUser</strong> method which has a callback handler that saves the user info, finishes the current activity, and loads the <strong>LoggedInActivity</strong> with an intent.&#160; The <strong>registerUser</strong> method is very simple:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=registerUser.java"></script></p>  <p>Here we’re just creating a <strong>JsonObject</strong> which we fill with the username, password, and email address.&#160; We then pass that into the <strong>mTableAccounts</strong> <strong>insert</strong> method.&#160; <strong>mTableAccounts</strong> is a <strong>MobileServiceJsonTable</strong> which maps up to our Mobile Service’s <strong>Accounts</strong> table.&#160; Let’s next look at how we’re saving account info.</p>  <p><strong>Saving account info</strong></p>  <p>There are actually a few different methods on our <strong>AuthService</strong> that we use for saving and setting user data.&#160; Let’s look at the method called from our custom auth login and registration screens,<strong> setUserAndSaveData</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=setUserAndSaveData.java"></script></p>  <p>Here, we pull the userId and token out of the <strong>JsonObject</strong> that is sent into the method.&#160; We then pass that information into the <strong>setUserData</strong> method and call the <strong>saveUserData</strong> method.</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=setUserData.java"></script></p>  <p>The <strong>setUserData</strong> method creates a new <strong>MobileServiceUser</strong> using the userId and then sets the authentication token.&#160; It then set’s our <strong>mClient</strong>’s current user property to be that user.&#160; Afterwards, we check which provider was being used and save that for later.&#160; </p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=saveUserData.java"></script></p>  <p>Finally, in the <strong>saveUserData</strong> method, which is also called from the <strong>AuthenticationActivity</strong> after a user logins with one of the built in providers, we are writing the userId and token to <strong>SharedPreferences</strong>.&#160; SharedPreferences are a great way to easily store small amounts of data for your applications.&#160; However, the data is NOT encrypted and if the device has been rooted, it’s possible for other applications to access the data.&#160; Remember that with access to a user Id and token, you can make requests as that user so this should be considered sensitive information.&#160; You’ll probably want to pick a more secure method to store this information in your production apps.&#160; Now that we’ve seen how to save the data, let’s take a look at loading it when the app starts.</p>  <p><strong>Loading account info</strong></p>  <p>In the <strong>AuthenticationActivity</strong>’s <strong>onCreate</strong> method, we call the <strong>AuthService</strong>’s <strong>isUserAuthenticated</strong> method.&#160; If the user is already authenticated, then we go directly to the <strong>LoggedInActivity</strong> and skip any of the login options.&#160; That method looks like this:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=isUserAuthenticated.java"></script></p>  <p>Here we check to see if we’ve saved <strong>UserData</strong> before.&#160; If we have, then we pull out the userid and token and then call the <strong>setUserData</strong> method with those values.&#160; Finally, we return a boolean which says if the user is authenticated or not.&#160; Let’s look at the <strong>LoggedInActivity</strong> and talk about logging out.</p>  <p><strong>Logging the user out</strong></p>  <p>Once we’ve logged into our app we get to the <strong>LoggedInActivity</strong>:</p>  <p align="center"><img title="Logged in activity" alt="Logged in activity" src="http://storage.chrisrisner.com/images/android-auth-logged-in.jpg" width="226" height="332" /></p>  <p>When we tap the <strong>Logout</strong> button we are just calling the <strong>logout</strong> method on the <strong>mAuthService</strong>:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=logout.java"></script></p>  <p>There’s a lot going on here.&#160; First we use <strong>CookieManager</strong> to remove all of the cookies in our application.&#160; This is done because when you login using one of the built-in providers, they place cookies on your web view.&#160; So, if you were to go back and login again, the provider would see those cookies and say “you’re already logged in”.&#160; One important thing to note is that we’re removing ALL of the cookies.&#160; If you’re using web views for other things, you may want to look at the specific cookies for the login providers and remove those.&#160; Next, we’re deleting the data stored in shared preferences.&#160; So, if we’ve stored the userid and token there, this will remove them.&#160; Then we call the <strong>MobileServiceClient</strong>’s <strong>logout</strong> method which removes the local user property.&#160; Finally, if we passed in a value saying we should redirect to the login page, we’ll load the <strong>AuthenticationActivity </strong>with an intent.&#160; Importantly, we’re passing the <strong>FLAG_ACTIVITY_CLEAR_TOP </strong>and <strong>FLAG_ACTIVITY_NEW_TASK</strong> to our intent.&#160; This is basically saying remove all the other activities from our navigation stack and take me back to the authentication activity.&#160; The last thing we’ll talk about today is dealing with expired tokens.</p>  <p><strong>Handling expired tokens</strong></p>

<p><strong>Update 5-13-2013</strong>: Since writing this I found an easier way to do the retry request that does not require the changes to the SDK.  Please read more about this at this post on <a href="http://chrisrisner.com/CountDownLatchs-and-Android" title="Android and CountDownLatchs">CountDownLatchs</a>.
</p>

<p>This is the most complicated part to explain because it required a few changes to the Android SDK (as mentioned near the top).&#160; The idea is that if your app makes a request to your Mobile Service that SHOULD get through because their user is authenticated and you receive a 401 (unauthorized error) it means the user token you’re passing over has expired.&#160; There are a couple of ways we can handle this.&#160; In the callback handler for every method that we have that interacts with our Mobile Service, we could check for a 401 response, or we can handle things in one place: the <strong>ServiceFilter</strong>’s <strong>handleRequest</strong> method.&#160; Basically, when you instantiate your <strong>MobileServiceClient</strong> and call<strong> withFilter</strong> on it, you can specify a filter that will be called for each request you make to your Mobile Service.&#160; This is a pretty complex method so we’ll go through it slowly:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=ServiceFilter.java"></script></p>  <p>Inside of the <strong>handleRequest</strong> method we’re just calling the <strong>NextServiceFilterCallback</strong>’s <strong>onNext</strong> method.&#160; Inside the <strong>ServiceFilterResponseCallback</strong>’s <strong>onResponse</strong> method is where the magic happens.&#160; First we check to see if the status code on the response was a 401, if it wasn’t we skip the rest of the code and call <strong>responseCallback.onResponse</strong> at the bottom of the method and proceed on as normal.&#160; If it was a 401 though, we do some more advanced stuff.</p>  <p>First, we call the <strong>logout</strong> method that we looked at above.&#160; In this situation, we’re passing false into that method call to indicate that we don’t want to boot the user back to the <strong>AuthenticationActivity</strong>.&#160; We then check to see if we should retry failed requests (the <strong>mShouldRetryAuth </strong>variable).&#160; We’re also checking to see if the user used custom auth.&#160; We’re not facilitating re-logging in if the user did custom auth but you could easily do that by creating a dialog with custom auth (we just have a full activity right now).&#160; If we shouldn’t retry or they did use custom auth, we go down to the bottom of the method and call logout, this time booting the user back to the first activity, and then process the response again.</p>  <p>Now that we’re ready to retry, let’s dig into what happens.&#160; First, we get access to the <strong>Application </strong>object.&#160; We’ve overridden the <strong>Application </strong>object so that it has a reference to whatever the current <strong>Activity</strong> is.&#160; We’re then using that to set the <strong>Context</strong> of our <strong>MobileServiceClient</strong>.&#160; We’re doing this because the client need’s to have a context for whatever is currently visible in order to pop back up the login dialog.&#160; If you were to leave a non-visible <strong>Context</strong> as the context or pass in the <strong>Application Context</strong>, your call to login would fail.&#160; We then call the <strong>onResponse</strong> method because the SDK will currently crash if you don’t (I filed an issue on this and they’re working on a fix).&#160; Then we tell our client to <strong>login</strong> again and do that on the UI thread.</p>  <p>If the user does not login successfully, we log the user out and kick them back to <strong>AuthenticationActivity</strong>.&#160; If they do login successfully, we first call <strong>saveUserData</strong> to store the authentication info.&#160; Then we call the request’s <strong>getPreviousRequest</strong> method.&#160; This is where we get into the changes I had to make to the SDK to facilitate retrying requests.&#160; The previous request is essentially a copy of the current request.&#160; We remove it’s <strong>X-ZUMO-AUTH</strong> header which contains the user token and then replace it with the current user’s auth token.&#160; The idea being that we’re removing the invalid token that was set on the previous request and then setting the new valid token.&#160; We then pull out the URL of the previous request and add a bypass query parameter to it.&#160; This is only necessary because of how I’m testing for 401 errors.&#160; To test 401s, I’m calling a method on my Mobile Service that will always return a 401 error UNLESS the bypass query string parameter is present.&#160; You wouldn’t include a bypass query string parameter if you were just handling expired tokens.&#160; Finally, we do a switch on the previous request type and perform the appropriate operation on the <strong>previousTable</strong>.&#160; This is what retries our previous request.&#160; Again, if you didn’t want to facilitate retrying, you could JUST force the user out on a 401 error and you wouldn’t need the forked SDK.&#160; </p>  <p>Lastly, let’s look at the method we call to trigger testing a 401:</p>  <p><script src="https://gist.github.com/ChrisRisner/5416548.js?file=testForced401.java"></script></p>  <p>Here all we’re doing is creating a <strong>JsonObject</strong> and then sending that to <strong>mTableBadAuth</strong>’s <strong>insert</strong> method.&#160; As we saw in the <a title="Authentication and Mobile Services" href="http://chrisrisner.com/Authentication-with-Windows-Azure-Mobile-Services">preceding article</a>, the <strong>Insert </strong>script for the bad auth table is set to handle returning a 401 without the presence of the<strong> bypass</strong> parameter.&#160; </p>  <p><strong>Conclusion</strong></p>  <p>Today we looked at how to implement an Android client with access to each of the built in authentication providers as well as how to handle custom authentication.&#160; We reviewed how to register a user for new accounts as well as how to login with them.&#160; We also saw how to cache the user’s auth token so that they don’t have to login each time the app runs and how to reload that auth information.&#160; With all of this, you could pretty much just drop in whatever functionality you want only logged in users to have access to.&#160; There are some further things you might want to handle such as sending an email to the user after they register for an account to make sure the email address they used is valid (which you can do with <a title="Sending email with SendGrid and Mobile Services" href="http://www.windowsazure.com/en-us/develop/mobile/tutorials/send-email-with-sendgrid/">SendGrid</a>) as well as offering <strong>Forgotten Password</strong> functionality.&#160; These are things that are definitely part of a full application and should be considered.</p>