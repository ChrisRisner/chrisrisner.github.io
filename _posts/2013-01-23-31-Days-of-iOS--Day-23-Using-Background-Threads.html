---
layout: post
title: "31 Days of iOS: Day 23-Using Background Threads"
date: Wed Jan 23 2013 09:47:00 GMT-0800 (PST)
comments: true
status: publish
type: post
published: true
categories: [Mobile, Objective-C, XCode, iOS]
excerpt: "This is day 23 of the 31 Days of iOS.  In this entry we discuss how long running processes can block the main or UI thread.  We'll talk about a solution to this using background threads and dispatching."
logoUrl: null
keywords: iOS,31 days of iOS,Apple,Apple iOS,background,thread,block,foreground,sleep,lock,dispatch_async,DISPATCH_QUEUE_PRIORITY_BACKGROUND, dispatch_get_main_queue,iOS Introduction,iOS Tutorial,iOS for Beginners,Beginners,walkthrough
filepath: 2013-01-23-31-Days-of-iOS--Day-23-Using-Background-Threads.html
disqus_identifier: 31-Days-of-iOS--Day-23–Using-Background-Threads
redirect_from:
  - /2013-01-23-31-Days-of-iOS--Day-23%E2%80%93Using-Background-Threads/
  - /2013-01-23-31-Days-of-iOS--Day-23–Using-Background-Threads/
  - /31-Days-of-iOS--Day-23–Using-Background-Threads/
  - /31-Days-of-iOS--Day-23–Using-Background-Threads
---
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" align="right" src="http://chrisrisner.com/upload/200px-Apple-logo.png" width="170" height="208" />Welcome to Day 23 of the <a title="31 Days of iOS" href="http://chrisrisner.com/31-Days-of-iOS">31 Days of iOS</a>.&#160; <a title="Day 22: Using the gallery" href="http://chrisrisner.com/31-Days-of-iOS--Day-22%E2%80%93Using-the-Gallery">Yesterday</a> we wrapped up a two part series on using the camera and photo gallery to get access to pictures.&#160; Today we’re going to switch gears and talk about using background threads.&#160; We’ll first explain why it’s important to know how to do this and then we’ll go through a simple example of how to do it.&#160; We’ll be starting with a brand new project, but if you’d like to <a title="iOS Day 23" href="http://storage.chrisrisner.com/codesamples/iOSDayTwentyThree.zip">follow along with the completed code, you can access it here</a>.</p>  <p><strong>Why use background threads</strong></p>  <p>When you build your applications, you need to be extremely cognizant of the processing that goes on on the UI thread.&#160; If the operations you’re performing are too resource and time intensive, the user interface will be unresponsive which always leads to a very poor user experience.&#160; If you want a very quick example of this in action, create a new project and alter the <strong>ViewController.m</strong>’s <strong>viewDidLoad </strong>method to be the following:</p>  <p><script src="https://gist.github.com/4334809.js?file=viewDidLoad1.m"></script></p>  <p>Here we’re putting a sleep (using <strong>NSThread sleepForTimeInterval</strong>) in a for loop.&#160; The effect of this is that we’re doing some very time intensive processing.&#160; It will take a full six seconds before the <strong>viewDidLoad</strong> method is finished.&#160; This means that our UI won’t load until these 6 seconds of processing are complete.&#160; Now the for loop in the code above is very meaningless and would never be found in a good application (or even a decently coded one).&#160; However, it wouldn’t be hard to do a similar amount of REAL processing.&#160; Just think of needing to pull down several images when loading or having to hit a slow responding server or do a lot of file processing.&#160; Now some of these things already have ways of wrapping a lot of the processing so you wouldn’t have to worry about it (such as doing asynchronous web requests using <strong>NSURLConnection</strong>’s <strong>sendAscynchronousRequest</strong>.&#160; In situations where iOS and objective-c don’t wrap the functionality in a way that prevents it from occurring on the UI thread, you can use background threads to prevent hanging up the UI.&#160; Let’s dive in and look at an example of how to do this now.&#160; </p>  <p><strong>Creating our project and handling the UI</strong></p>  <p>Open up Xcode and choose <strong>File</strong>, <strong>New</strong>, <strong>Project</strong>.&#160; We’ll use a <strong>Single View Application </strong>and name it <strong>DayTwentyThree</strong>:</p>  <p align="center"><img title="iOS Day 23 new project" alt="iOS Day 23 new project" src="http://storage.chrisrisner.com/images/31iosday23-new-project.jpg" /></p>  <p>Open up <strong>MainStoryboard.storyboard</strong> and let’s handle our initial UI.&#160; We’re going to drop three round rect buttons and a label on our UI.&#160; Make sure you set the <strong>Lines</strong> property of the label in the <strong>Attributes Inspector</strong> to <strong>0</strong> so it will allow us to print out multiple lines.&#160; Your UI should look like this:</p>  <p align="center"><img title="iOS Day 23 UI" alt="iOS Day 23 UI" src="http://storage.chrisrisner.com/images/31iosday23-project-ui.jpg" /></p>  <p>After that, open up the <strong>Assistant Editor</strong> in the top right of Xcode and <strong>control + click and drag</strong> from each button and the label over to the view controller code.&#160; You’ll want to create actions for each button and an outlet for the label.&#160; When you’re done, the <strong>ViewController.h</strong> file will look like this:</p>  <p><script src="https://gist.github.com/4334809.js?file=ViewController.h"></script></p>  <p>Now we can implement some processing.</p>  <p><strong>Reexamining slow foreground processing</strong></p>  <p>Open up <strong>ViewController.m</strong>.&#160; The first thing we’re going to do is duplicate the code we saw above so we can better understand how it impacts the UI thread.&#160; Let’s put that for loop with the sleep statements into the <strong>tappedProcessInForeground </strong>method:</p>  <p><script src="https://gist.github.com/4334809.js?file=tappedProcessInForeground.m"></script></p>  <p>This code is the same as we saw above.&#160; We have a for loop and then calls to the <strong>NSThread </strong>method <strong>sleepForTimeInterval</strong>.&#160; Before we can runt he app and see how this really affects UI interaction, let’s also implement the <strong>tappedUpdateLabel</strong> method:</p>  <p><script src="https://gist.github.com/4334809.js?file=tappedUpdateLabel.m"></script></p>  <p>All we’re doing in this method is getting the current time and converting it into an <strong>NSString</strong>.&#160; We then use that to put the current time at the top of the label (by appending the label text to the current time’s <strong>NSString </strong>value).&#160; Now we can run our app and better understand locking or hanging the UI thread.</p>  <p><strong>Locking the UI thread</strong></p>  <p>Run your app in the simulator (or on a device).&#160; The first thing you’ll want to do, is tap the second button, the <strong>Update Label</strong> button.&#160; You should see the current time appear at the top of the label below the buttons:</p>  <p align="center"><img title="Updating the label a few times" alt="Updating the label a few times" src="http://storage.chrisrisner.com/images/31iosday23-updating-label.jpg" width="265" height="322" /></p>  <p>Now, what you should do is tap the <strong>Process in Foreground </strong>button, and then tap the <strong>Update Label</strong> button several times immediately after.&#160; What should happen is that the <strong>Process in Foreground</strong> button will stay blue for a few seconds and the label won’t update:</p>  <p align="center"><img title="Waiting on the UI Thread" alt="Waiting on the UI Thread" src="http://storage.chrisrisner.com/images/31iosday23-waiting-on-thread.jpg" width="267" height="334" /></p>  <p>After 6 seconds, the processing will finish and the <strong>Process in Foreground </strong>button will return to white.&#160; Additionally, the taps of the <strong>Update Label</strong> button will finally go through resulting in the time showing in the label for a time at least a few seconds after it was actually tapped (depending on how fast you tap):</p>  <p align="center"><img title="After thread finishes" alt="After thread finishes" src="http://storage.chrisrisner.com/images/31iosday23-after-thread.jpg" width="256" height="334" /></p>  <p>The reason this happens is that as long as we’re doing all that processing within the method directly called by the UI, it’s preventing anything from being processed.&#160; So, even though you’ve tapped the button to update the label, it doesn’t update.&#160; However, the taps DO go through once the UI thread returns.&#160; This is really the best we can hope for because we still want whatever the user has done to <em>go through</em> after our processing returns, but it’s far from optimal.&#160; Instead, what would be best, is for the processing to happen in a background thread where it won’t lock the UI thread.&#160; We’ll do that next.</p>  <p><strong>Processing on the background thread</strong></p>  <p>We’ll next implement the <strong>tappedProcessInBackground</strong> method.&#160; We’ll first implement this method to just do our processing in the backend and not block the UI thread.&#160; The code for this is actually not very complicated:</p>  <p><script src="https://gist.github.com/4334809.js?file=tappedProcessInBackground1.m"></script></p>  <p>We first call <strong>dispatch_asycn</strong> and send in the <strong>dispatch_get_global_queue </strong>method to get the <strong>DISPATCH_QUEUE_PRIORITY_BACKGROUND</strong>.&#160; This background queue is kind of a default very low priority queue that can be used for low priority processing.&#160; <strong>dispatch_get_global_queue</strong> is used to get shared concurrent queues, of which the background queue is one of them.&#160; We also pass a block of code that will do the same processing we did above.&#160; Now if you run your app and tap the <strong>Process in Background</strong> button, you’ll be able to tap the <strong>Update Label</strong> method immediately after and it will update the label.&#160; This is because we’re doing our EXTREME processing in a background thread and not on the UI thread.</p>  <p><strong>Updating the UI when our background thread is done</strong></p>  <p>It’s important to know how to update the UI thread once you’re done with your expensive processing as you’ll often be pulling or opening something that will then affect the UI.&#160; We’ll look at how to do that now.&#160; The first thing we’re going to do is add another method to the <strong>ViewController.m</strong> file:</p>  <p><script src="https://gist.github.com/4334809.js?file=updateLabelWhenBackgroundDone.m"></script></p>  <p>The purpose of this method is to just update the label with the text <strong>Background Done!</strong>.&#160; We’re going to call this method when our background processing is done.&#160; Now we’ll go back and change the <strong>tappedProcessInBackground</strong> method:</p>  <p><script src="https://gist.github.com/4334809.js?file=tappedProcessInBackground2.m"></script></p>  <p>The only difference to this method is the call after our for loop.&#160; The changes are another call to <strong>dispatch_async</strong>.&#160; In this call we call <strong>dispatch_get_main_queue</strong> and pass in a block which will call the <strong>updateLabelWhenBackgroundDone</strong> method.&#160; The <strong>dispatch_get_main_queue</strong> get’s the application’s main queue which is what the UI is running on.&#160; So we can use this to then call methods on that main queue.&#160; Now, when we run our app, we can tap the <strong>Process in Background </strong>method, then tap the <strong>Update Label</strong> button several times, and when the background thread is done processing, our UI will be updated:</p>  <p align="center"><img title="updating from the background thread" alt="updating from the background thread" src="http://storage.chrisrisner.com/images/31iosday23-finished-ui.jpg" width="254" height="324" /></p>  <p><strong>Conclusion</strong></p>  <p>Today we talked about why it’s important to consider what sort of processing you’re doing on your UI thread and how you can see the impact of doing too much processing.&#160; Today’s example was fairly arbitrary as it wasn’t really doing anything, however, there are many different things you might do in an application that could take a long time.&#160; If you find yourself doing these things in your app, using a background thread is a good idea.&#160; It’s important to know that we just skimmed the surface of what you can do with, and how you can do, background threads.&#160; If you’re interested in doing anything more advanced, I’d recommend you do some research into <a title="iOS Dispatch Queues" href="http://developer.apple.com/library/ios/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html">dispatch queues</a>, <a title="Grand Central Dispatch" href="https://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">Grand Central Dispatch</a>, and <a title="NSOperation" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Reference/NSOperationQueue_class/Reference/Reference.html">NSOperation</a>.&#160; The point is that the iOS threading system can get very complex if you want it to.&#160; You may need to go beyond the global background queue.&#160; You can <a title="iOS Day 23" href="http://storage.chrisrisner.com/codesamples/iOSDayTwentyThree.zip">download the completed code from today’s walkthrough here</a>.</p>