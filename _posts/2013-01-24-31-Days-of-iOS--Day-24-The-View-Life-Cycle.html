---
layout: post
title: "31 Days of iOS: Day 24-The View Life Cycle"
date: Thu Jan 24 2013 09:11:00
commentsOn: true
status: publish
type: post
published: true
categories: [Mobile, Objective-C, XCode, iOS]
excerpt: "This is day 24 in the 31 Days of iOS.  This article covers the view lifecycle and all of the events that are fired during the course of the creation, display, and removal of a view controller."
logoUrl: null
keywords: iOS,31 days of iOS,Apple,Apple iOS,view life cycle,viewDidLoad,didReceiveMemoryWarning,viewDidAppear,viewWillAppear,layoutSubViews,iOS Introduction,iOS Tutorial,iOS for Beginners,Beginners,walkthrough
filepath: 2013-01-24-31-Days-of-iOS--Day-24-The-View-Life-Cycle.html
disqus_identifier: 31-Days-of-iOS--Day-24–The-View-Life-Cycle
redirect_from:
  - /2013-01-24-31-Days-of-iOS--Day-24%E2%80%93The-View-Life-Cycle/
  - /2013-01-24-31-Days-of-iOS--Day-24–The-View-Life-Cycle/
  - /31-Days-of-iOS--Day-24–The-View-Life-Cycle/
  - /31-Days-of-iOS--Day-24–The-View-Life-Cycle
---
<p><img style="margin: 0px 0px 5px 5px; display: inline; float: right" align="right" src="http://chrisrisner.com/upload/200px-Apple-logo.png" width="170" height="208" />Welcome to Day 24 of the <a title="31 Days of iOS" href="http://chrisrisner.com/31-Days-of-iOS">31 Days of iOS</a>.&#160; <a title="Day 23: Using Background Threads" href="http://chrisrisner.com/31-Days-of-iOS--Day-23%E2%80%93Using-Background-Threads">Yesterday</a>, we went over how to do processing in a background thread to prevent hanging up the UI thread.&#160; Today we’re going to talk about the view lifecycle.&#160; By that we are referring to the different events and methods that are automatically fired on your view controller in the normal course of using the app.&#160; We’ll follow up tomorrow by talking about Application life cycle events which differ from the ones on the view.&#160; We’ll be starting with a brand new project, but if you’d like to follow along with the <a title="iOS Day 24 Source Code" href="http://storage.chrisrisner.com/codesamples/iOSDayTwentyFour.zip">completed code, you can access it here</a>.</p>  <p><strong>Creating our project</strong></p>  <p>Open up Xcode and choose <strong>File</strong>, <strong>New</strong>, <strong>Project</strong>.&#160; We’ll use a <strong>Single View Application</strong> and name it<strong> DayTwentyFour</strong>:</p>  <p align="center"><img title="iOS day 24 new project" alt="iOS day 24 new project" src="http://storage.chrisrisner.com/images/31iosday24-new-project.jpg" width="500" height="421" /></p>  <p>Some of the life cycle events depend upon going from one view to another, so we’re going to alter our UI a bit to facilitate those events showing up.&#160; Open up <strong>MainStoryboard.storyboard</strong>.&#160; First, select the view that is already on your storyboard, and go to the <strong>Editor</strong> menu and choose <strong>Embed In</strong> and select <strong>Navigation Controller</strong>.&#160; We’ll use this to help make it easier to move to a new view and back.&#160; Next, drag a <strong>View Controller</strong>, from the element selector in the bottom right, onto the storyboard.&#160; When you’re done, the storyboard should look like this (zoomed out):</p>  <p align="center"><img title="Storyboard with new view" alt="Storyboard with new view" src="http://storage.chrisrisner.com/images/31iosday24-new-view.jpg" /></p>  <p>Next, drag a <strong>round rect button</strong> from the element selector onto the original <strong>View Controller</strong> (the one in the middle in the image above).&#160; Next,<strong> control + click and drag</strong> from the button to the <strong>View Controller</strong> on the right and let go.&#160; In the popup that comes up, select <strong>Push</strong>.&#160; When you’re done, the right two views should look like this:</p>  <p align="center"><img title="View Controllers" alt="View Controllers" src="http://storage.chrisrisner.com/images/31iosday24-view-controllers.jpg" /></p>  <p>Our UI is done now.&#160; If you run your app, you should be able to tap the <strong>Show View</strong> button and the other view will appear.&#160; You should then be able to tap a button on the top left of the view to return to our first view.&#160; With that working, we can start looking at the life cycle events.</p>  <p><strong>Initial view controller life cycle events</strong></p>  <p>Open up <strong>ViewController.m</strong> and you’ll see a&#160; few methods that are added by default:&#160; <strong>viewDidLoad</strong> and <strong>didReceiveMemoryWarning</strong>.&#160; After adding a log statement, our <strong>viewDidLoad</strong> method will look like this by default:</p>  <p><script src="https://gist.github.com/4391376.js?file=viewDidLoad.m"></script></p>  <p>Notice the first call is to <strong>[super viewDidLoad]</strong>.&#160;&#160;&#160; This means we’re calling the original <strong>ViewController</strong> classes implementation of the <strong>viewDidLoad</strong> method.&#160; We do this because the root class does a lot of setup that we want to use but don’t want to code ourselves.&#160; After that is done, we can perform whatever setup we want.&#160; This isn’t the first method called in the life cycle of our view but is the only one that is always called and is put in the class by default.&#160; As it says in the comment, additional setup should be performed here.&#160; However, if you need to do anything that is determined by screen geometry, frame size, UI element size, etc, you’ll want to wait until a later method.&#160; </p>  <p>The second method present is <strong>didReceiveMemoryWarning</strong>.&#160; This method also just calls the <strong>super</strong> class’ method of the same name.&#160; This method will only be called when your app is using up too much memory and is an indicator to you that you should release memory if possible.&#160; With Automatic Reference Counting (ARC) you typically aren’t handling deallocating memory so you may think you don’t need to worry about this method or what it’s being called means.&#160; However, you still have control over how much memory you are allocating and where it’s being used.&#160; I would advise you to keep an eye out for this method being called and, if you do see it being called, refactoring or redesigning your code.&#160; </p>  <p><strong>Initializers</strong></p>  <p>There are a few different initialization methods that can be called when our view controller is first created:&#160; <strong>initWithNibName</strong>, <strong>initWithCoder</strong>, and <strong>init</strong>.&#160; In our app today, we’ll only see the method <strong>initWithCoder</strong> being called.&#160; This method is called as a result of us loading our view from a storyboard.&#160; If we were instead using <strong>Nib</strong> files (which was standard prior to storyboards and is still possible if you want) the <strong>initWithNibName</strong> method would be called.&#160; Lastly, if we were instantiating our view controller class on our own without using the other two methods, <strong>init</strong> would be called (as the standard initializer for classes).&#160; I’ve gone ahead and implemented each of these methods (which like the two mentioned above call their <strong>super</strong> method of the same name) and added a log statement so we can see a complete flow in just a few minutes.&#160; There is one other method which is sort of like an init method that we aren’t going to use today but will talk about:&#160; <strong>loadView</strong>.&#160; This method is called automatically on your view (and is normally handled by the <strong>super </strong>class).&#160; If you were not going to use a view from the storyboard or a nib file (that is you wanted to create your whole UI programmatically) you could override this method and set your view up here.&#160; Since we want to handle things the <em>easy</em> way and use storyboards, we won’t use the <strong>loadView </strong>method.&#160; </p>  <p><strong>viewDid</strong> <strong>and viewWill</strong></p>  <p>The next set of methods all either start with <strong>viewDid</strong> or <strong>viewWill</strong>.&#160; These methods are:&#160; <strong>viewWillAppear</strong>, <strong>viewWillDisappear</strong>, <strong>viewWillLayoutSubviews</strong>, <strong>viewDidAppear</strong>, <strong>viewDidDisappear</strong>, and <strong>viewDidLayoutSubviews</strong>.&#160; After the <strong>viewDidLoad </strong>method is called, <strong>viewWillAppear</strong> is called.&#160; When this method is called, the geometry of your view has been figured out and you’re safe to do any processing that is dependent upon that.&#160; It’s important to remember that in the life of a view controller, the <strong>viewDidLoad</strong> method is only called once but <strong>viewWillAppear</strong> might be called many times.&#160; If you wanted data you were presenting to the user to be updated each time the user returned or went to your view, you might want to do that updating in the <strong>WillAppear</strong> method instead of <strong>DidLoad</strong>.&#160; If it’s something that only needs to happen once, it’s probably best left in <strong>DidLoad</strong>.&#160; </p>  <p>After that, <strong>viewWillLayoutSubviews</strong> is called followed by<strong> viewDidLayoutSubviews</strong> and <strong>viewDidAppear</strong>.&#160; If you tap the button on our view (which will cause the second view we created to show up) you’ll then see the <strong>viewWillDisappear </strong>and <strong>viewDidDisappear</strong> methods be called.&#160; This happens because your view isn’t being completely deallocated when you push another view on top of the current one.&#160; Instead it is still stored in memory so it can be quickly restored to the screen when the user goes back.&#160; One example of something you might want to do on <strong>WillDisappear</strong> is to save to storage any text data entered into view.&#160; That way, if the user leaves your app before returning to the view, you can load that text data back into the view to give the user a seamless experience and not require them to retype it.</p>  <p>Finally, when the user does go back, we again see the <strong>viewWillAppear</strong>, <strong>viewWillLayoutSubviews</strong>, <strong>viewDidLayoutSubviews</strong>, and <strong>viewDidAppear</strong> methods being called.</p>  <p><strong>Event flow</strong></p>  <p>Let’s take a less wordy look at the flow of our app:</p>  <p><script src="https://gist.github.com/4391376.js?file=eventFlow.m"></script></p>  <p>This is the all of the events that are logged when our view first appears.&#160; If we look at just the event flow that happens when we tap the <strong>Show view</strong> button and then return, we get this:</p>  <p><script src="https://gist.github.com/4391376.js?file=secondEventFlow.m"></script></p>  <p>This makes it a little easier to see what order these events are called in.</p>  <p><strong>What about closing the app?</strong></p>  <p>Before we finish today, hit the home button when your application is running.&#160; You’ll notice that no events are triggered.&#160; This is because leaving the app doesn’t trigger any view life cycle events.&#160; Instead, it will fire off application life cycle events.&#160; We’ll talk more about these tomorrow.</p>  <p><strong>Conclusion</strong></p>  <p>Today we looked at the life cycle of a view controller in an iOS application.&#160; By default when you create a new view controller, two methods that are part of the life cycle are present.&#160; However, there are many more you can implement depending on when you need to perform what actions.&#160; One event type I didn’t talk about today which <em>could</em> be thought of as life cycle methods is the calls for orientation changes.&#160; You can read more about them in Day 16’s article on device orientation.&#160; You can <a title="iOS Day 24 Source Code" href="http://storage.chrisrisner.com/codesamples/iOSDayTwentyFour.zip">download the completed code from today’s walkthrough here</a>.</p>